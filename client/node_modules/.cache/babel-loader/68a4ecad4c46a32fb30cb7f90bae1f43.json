{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst validate = require('aproba');\n\nconst fs = require('graceful-fs');\n\nconst isInside = require('path-is-inside');\n\nconst vacuum = require('fs-vacuum');\n\nconst chain = require('slide').chain;\n\nconst asyncMap = require('slide').asyncMap;\n\nconst readCmdShim = require('read-cmd-shim');\n\nconst iferr = require('iferr');\n\nexports = module.exports = rm;\n\nfunction rm(target, opts, cb) {\n  var targetPath = path.normalize(path.resolve(opts.prefix, target));\n\n  if (opts.prefixes.indexOf(targetPath) !== -1) {\n    return cb(new Error('May not delete: ' + targetPath));\n  }\n\n  var options = {};\n\n  if (opts.force) {\n    options.purge = true;\n  }\n\n  if (opts.base) options.base = path.normalize(path.resolve(opts.prefix, opts.base));\n\n  if (!opts.gently) {\n    options.purge = true;\n    return vacuum(targetPath, options, cb);\n  }\n\n  var parent = options.base = options.base || path.normalize(opts.prefix); // Do all the async work we'll need to do in order to tell if this is a\n  // safe operation\n\n  chain([[isEverInside, parent, opts.prefixes, opts.log], [readLinkOrShim, targetPath], [isEverInside, targetPath, opts.prefixes, opts.log], [isEverInside, targetPath, [parent], opts.log]], function (er, results) {\n    if (er) {\n      if (er.code === 'ENOENT') return cb();\n      return cb(er);\n    }\n\n    var parentInfo = {\n      path: parent,\n      managed: results[0]\n    };\n    var targetInfo = {\n      path: targetPath,\n      symlink: results[1],\n      managed: results[2],\n      inParent: results[3]\n    };\n    isSafeToRm(parentInfo, targetInfo, opts.name, opts.log, iferr(cb, thenRemove));\n\n    function thenRemove(toRemove, removeBase) {\n      if (!toRemove) return cb();\n      if (removeBase) options.base = removeBase;\n      return vacuum(toRemove, options, cb);\n    }\n  });\n}\n\nexports._isSafeToRm = isSafeToRm;\n\nfunction isSafeToRm(parent, target, pkgName, log, cb) {\n  log.silly('gentlyRm', 'parent.path =', parent.path);\n  log.silly('gentlyRm', 'parent.managed =', parent.managed && parent.managed.target + ' is in ' + parent.managed.path);\n  log.silly('gentlyRm', 'target.path = ', target.path);\n  log.silly('gentlyRm', 'target.symlink =', target.symlink);\n  log.silly('gentlyRm', 'target.managed =', target.managed && target.managed.target + ' is in ' + target.managed.path);\n  log.silly('gentlyRm', 'target.inParent = ', target.inParent); // The parent directory or something it symlinks to must eventually be in\n  // a folder that we maintain.\n\n  if (!parent.managed) {\n    log.info('gentlyRm', parent.path, 'is not contained in any directory ' + pkgName + ' is known to control or ' + 'any place they link to');\n    return cb(clobberFail(target.path, 'containing path ' + parent.path + \" isn't under \" + pkgName + \"'s control\"));\n  } // The target or something it symlinks to must eventually be in the parent\n  // or something the parent symlinks to\n\n\n  if (target.inParent) {\n    var actualTarget = target.inParent.target;\n    var targetsParent = target.inParent.path; // if the target.path was what we found in some version of parent, remove\n    // using that parent as the base\n\n    if (target.path === actualTarget) {\n      return cb(null, target.path, targetsParent);\n    } else {\n      // If something the target.path links to was what was found, just\n      // remove target.path in the location it was found.\n      return cb(null, target.path, path.dirname(target.path));\n    }\n  } // If the target is in a managed directory and is in a symlink, but was\n  // not in our parent that usually means someone else installed a bin file\n  // with the same name as one of our bin files.\n\n\n  if (target.managed && target.symlink) {\n    log.warn('rm', 'not removing', target.path, \"as it wasn't installed by\", parent.path);\n    return cb();\n  }\n\n  if (target.symlink) {\n    return cb(clobberFail(target.path, target.symlink + ' symlink target is not controlled by ' + pkgName + ' ' + parent.path));\n  } else {\n    return cb(clobberFail(target.path, 'is outside ' + parent.path + ' and not a link'));\n  }\n}\n\nfunction clobberFail(target, msg) {\n  validate('SS', arguments);\n  var er = new Error('Refusing to delete ' + target + ': ' + msg);\n  er.code = 'EEXIST';\n  er.path = target;\n  return er;\n}\n\nfunction isENOENT(err) {\n  return err && err.code === 'ENOENT';\n}\n\nfunction notENOENT(err) {\n  return !isENOENT(err);\n}\n\nfunction skipENOENT(cb) {\n  return function (err, value) {\n    if (isENOENT(err)) {\n      return cb(null, false);\n    } else {\n      return cb(err, value);\n    }\n  };\n}\n\nfunction errorsToValues(fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments);\n    var cb = args.pop();\n    args.push(function (err, value) {\n      if (err) {\n        return cb(null, err);\n      } else {\n        return cb(null, value);\n      }\n    });\n    fn.apply(null, args);\n  };\n}\n\nfunction isNotError(value) {\n  return !(value instanceof Error);\n}\n\nexports._isEverInside = isEverInside; // return the first of path, where target (or anything it symlinks to)\n// isInside the path (or anything it symlinks to)\n\nfunction isEverInside(target, paths, log, cb) {\n  validate('SAOF', arguments);\n  asyncMap(paths, errorsToValues(readAllLinks), iferr(cb, function (resolvedPaths) {\n    var errorFree = resolvedPaths.filter(isNotError);\n\n    if (errorFree.length === 0) {\n      var badErrors = resolvedPaths.filter(notENOENT);\n\n      if (badErrors.length === 0) {\n        return cb(null, false);\n      } else {\n        return cb(badErrors[0]);\n      }\n    }\n\n    readAllLinks(target, iferr(skipENOENT(cb), function (targets) {\n      cb(null, areAnyInsideAny(targets, errorFree, log));\n    }));\n  }));\n}\n\nexports._areAnyInsideAny = areAnyInsideAny; // Return the first path found that any target is inside\n\nfunction areAnyInsideAny(targets, paths, log) {\n  validate('AAO', arguments);\n  var toCheck = [];\n  paths.forEach(function (path) {\n    targets.forEach(function (target) {\n      toCheck.push([target, path]);\n    });\n  });\n\n  for (var ii = 0; ii < toCheck.length; ++ii) {\n    var target = toCheck[ii][0];\n    var path = toCheck[ii][1];\n    var inside = isInside(target, path);\n    if (!inside) log.silly('isEverInside', target, 'is not inside', path);\n    if (inside && path) return inside && path && {\n      target: target,\n      path: path\n    };\n  }\n\n  return false;\n}\n\nexports._readAllLinks = readAllLinks; // resolves chains of symlinks of unlimited depth, returning a list of paths\n// it's seen in the process when it hits either a symlink cycle or a\n// non-symlink\n\nfunction readAllLinks(path, cb) {\n  validate('SF', arguments);\n  var seen = {};\n\n  _readAllLinks(path);\n\n  function _readAllLinks(path) {\n    if (seen[path]) return cb(null, Object.keys(seen));\n    seen[path] = true;\n    resolveSymlink(path, iferr(cb, _readAllLinks));\n  }\n}\n\nexports._resolveSymlink = resolveSymlink;\nvar resolvedPaths = {};\n\nfunction resolveSymlink(symlink, cb) {\n  validate('SF', arguments);\n  var cached = resolvedPaths[symlink];\n  if (cached) return cb(null, cached);\n  readLinkOrShim(symlink, iferr(cb, function (symlinkTarget) {\n    if (symlinkTarget) {\n      resolvedPaths[symlink] = path.resolve(path.dirname(symlink), symlinkTarget);\n    } else {\n      resolvedPaths[symlink] = symlink;\n    }\n\n    return cb(null, resolvedPaths[symlink]);\n  }));\n}\n\nexports._readLinkOrShim = readLinkOrShim;\n\nfunction readLinkOrShim(path, cb) {\n  validate('SF', arguments);\n  fs.lstat(path, iferr(cb, function (stat) {\n    if (stat.isSymbolicLink()) {\n      fs.readlink(path, cb);\n    } else {\n      readCmdShim(path, function (er, source) {\n        if (!er) return cb(null, source); // lstat wouldn't return an error on these, so we don't either.\n\n        if (er.code === 'ENOTASHIM' || er.code === 'EISDIR') {\n          return cb(null, null);\n        } else {\n          return cb(er);\n        }\n      });\n    }\n  }));\n}","map":{"version":3,"sources":["/Users/moonbox/Documents/capstone/pantrypal/client/node_modules/npm/node_modules/gentle-fs/lib/rm.js"],"names":["path","require","validate","fs","isInside","vacuum","chain","asyncMap","readCmdShim","iferr","exports","module","rm","target","opts","cb","targetPath","normalize","resolve","prefix","prefixes","indexOf","Error","options","force","purge","base","gently","parent","isEverInside","log","readLinkOrShim","er","results","code","parentInfo","managed","targetInfo","symlink","inParent","isSafeToRm","name","thenRemove","toRemove","removeBase","_isSafeToRm","pkgName","silly","info","clobberFail","actualTarget","targetsParent","dirname","warn","msg","arguments","isENOENT","err","notENOENT","skipENOENT","value","errorsToValues","fn","args","Array","prototype","slice","call","pop","push","apply","isNotError","_isEverInside","paths","readAllLinks","resolvedPaths","errorFree","filter","length","badErrors","targets","areAnyInsideAny","_areAnyInsideAny","toCheck","forEach","ii","inside","_readAllLinks","seen","Object","keys","resolveSymlink","_resolveSymlink","cached","symlinkTarget","_readLinkOrShim","lstat","stat","isSymbolicLink","readlink","source"],"mappings":"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","sourcesContent":["'use strict'\n\nconst path = require('path')\nconst validate = require('aproba')\nconst fs = require('graceful-fs')\nconst isInside = require('path-is-inside')\nconst vacuum = require('fs-vacuum')\nconst chain = require('slide').chain\nconst asyncMap = require('slide').asyncMap\nconst readCmdShim = require('read-cmd-shim')\nconst iferr = require('iferr')\n\nexports = module.exports = rm\n\nfunction rm (target, opts, cb) {\n  var targetPath = path.normalize(path.resolve(opts.prefix, target))\n  if (opts.prefixes.indexOf(targetPath) !== -1) {\n    return cb(new Error('May not delete: ' + targetPath))\n  }\n  var options = {}\n  if (opts.force) { options.purge = true }\n  if (opts.base) options.base = path.normalize(path.resolve(opts.prefix, opts.base))\n\n  if (!opts.gently) {\n    options.purge = true\n    return vacuum(targetPath, options, cb)\n  }\n\n  var parent = options.base = options.base || path.normalize(opts.prefix)\n\n  // Do all the async work we'll need to do in order to tell if this is a\n  // safe operation\n  chain([\n    [isEverInside, parent, opts.prefixes, opts.log],\n    [readLinkOrShim, targetPath],\n    [isEverInside, targetPath, opts.prefixes, opts.log],\n    [isEverInside, targetPath, [parent], opts.log]\n  ], function (er, results) {\n    if (er) {\n      if (er.code === 'ENOENT') return cb()\n      return cb(er)\n    }\n    var parentInfo = {\n      path: parent,\n      managed: results[0]\n    }\n    var targetInfo = {\n      path: targetPath,\n      symlink: results[1],\n      managed: results[2],\n      inParent: results[3]\n    }\n\n    isSafeToRm(parentInfo, targetInfo, opts.name, opts.log, iferr(cb, thenRemove))\n\n    function thenRemove (toRemove, removeBase) {\n      if (!toRemove) return cb()\n      if (removeBase) options.base = removeBase\n      return vacuum(toRemove, options, cb)\n    }\n  })\n}\n\nexports._isSafeToRm = isSafeToRm\nfunction isSafeToRm (parent, target, pkgName, log, cb) {\n  log.silly('gentlyRm', 'parent.path =', parent.path)\n  log.silly('gentlyRm', 'parent.managed =',\n    parent.managed && parent.managed.target + ' is in ' + parent.managed.path)\n  log.silly('gentlyRm', 'target.path = ', target.path)\n  log.silly('gentlyRm', 'target.symlink =', target.symlink)\n  log.silly('gentlyRm', 'target.managed =',\n    target.managed && target.managed.target + ' is in ' + target.managed.path)\n  log.silly('gentlyRm', 'target.inParent = ', target.inParent)\n\n  // The parent directory or something it symlinks to must eventually be in\n  // a folder that we maintain.\n  if (!parent.managed) {\n    log.info('gentlyRm', parent.path,\n      'is not contained in any directory ' + pkgName + ' is known to control or ' +\n      'any place they link to')\n    return cb(clobberFail(target.path, 'containing path ' + parent.path +\n      \" isn't under \" + pkgName + \"'s control\"))\n  }\n\n  // The target or something it symlinks to must eventually be in the parent\n  // or something the parent symlinks to\n  if (target.inParent) {\n    var actualTarget = target.inParent.target\n    var targetsParent = target.inParent.path\n    // if the target.path was what we found in some version of parent, remove\n    // using that parent as the base\n    if (target.path === actualTarget) {\n      return cb(null, target.path, targetsParent)\n    } else {\n      // If something the target.path links to was what was found, just\n      // remove target.path in the location it was found.\n      return cb(null, target.path, path.dirname(target.path))\n    }\n  }\n\n  // If the target is in a managed directory and is in a symlink, but was\n  // not in our parent that usually means someone else installed a bin file\n  // with the same name as one of our bin files.\n  if (target.managed && target.symlink) {\n    log.warn('rm', 'not removing', target.path,\n      \"as it wasn't installed by\", parent.path)\n    return cb()\n  }\n\n  if (target.symlink) {\n    return cb(clobberFail(target.path, target.symlink +\n      ' symlink target is not controlled by ' + pkgName + ' ' + parent.path))\n  } else {\n    return cb(clobberFail(target.path, 'is outside ' + parent.path +\n      ' and not a link'))\n  }\n}\n\nfunction clobberFail (target, msg) {\n  validate('SS', arguments)\n  var er = new Error('Refusing to delete ' + target + ': ' + msg)\n  er.code = 'EEXIST'\n  er.path = target\n  return er\n}\n\nfunction isENOENT (err) {\n  return err && err.code === 'ENOENT'\n}\n\nfunction notENOENT (err) {\n  return !isENOENT(err)\n}\n\nfunction skipENOENT (cb) {\n  return function (err, value) {\n    if (isENOENT(err)) {\n      return cb(null, false)\n    } else {\n      return cb(err, value)\n    }\n  }\n}\n\nfunction errorsToValues (fn) {\n  return function () {\n    var args = Array.prototype.slice.call(arguments)\n    var cb = args.pop()\n    args.push(function (err, value) {\n      if (err) {\n        return cb(null, err)\n      } else {\n        return cb(null, value)\n      }\n    })\n    fn.apply(null, args)\n  }\n}\n\nfunction isNotError (value) {\n  return !(value instanceof Error)\n}\n\nexports._isEverInside = isEverInside\n// return the first of path, where target (or anything it symlinks to)\n// isInside the path (or anything it symlinks to)\nfunction isEverInside (target, paths, log, cb) {\n  validate('SAOF', arguments)\n  asyncMap(paths, errorsToValues(readAllLinks), iferr(cb, function (resolvedPaths) {\n    var errorFree = resolvedPaths.filter(isNotError)\n    if (errorFree.length === 0) {\n      var badErrors = resolvedPaths.filter(notENOENT)\n      if (badErrors.length === 0) {\n        return cb(null, false)\n      } else {\n        return cb(badErrors[0])\n      }\n    }\n    readAllLinks(target, iferr(skipENOENT(cb), function (targets) {\n      cb(null, areAnyInsideAny(targets, errorFree, log))\n    }))\n  }))\n}\n\nexports._areAnyInsideAny = areAnyInsideAny\n// Return the first path found that any target is inside\nfunction areAnyInsideAny (targets, paths, log) {\n  validate('AAO', arguments)\n  var toCheck = []\n  paths.forEach(function (path) {\n    targets.forEach(function (target) {\n      toCheck.push([target, path])\n    })\n  })\n  for (var ii = 0; ii < toCheck.length; ++ii) {\n    var target = toCheck[ii][0]\n    var path = toCheck[ii][1]\n    var inside = isInside(target, path)\n    if (!inside) log.silly('isEverInside', target, 'is not inside', path)\n    if (inside && path) return inside && path && {target: target, path: path}\n  }\n  return false\n}\n\nexports._readAllLinks = readAllLinks\n// resolves chains of symlinks of unlimited depth, returning a list of paths\n// it's seen in the process when it hits either a symlink cycle or a\n// non-symlink\nfunction readAllLinks (path, cb) {\n  validate('SF', arguments)\n  var seen = {}\n  _readAllLinks(path)\n\n  function _readAllLinks (path) {\n    if (seen[path]) return cb(null, Object.keys(seen))\n    seen[path] = true\n    resolveSymlink(path, iferr(cb, _readAllLinks))\n  }\n}\n\nexports._resolveSymlink = resolveSymlink\nvar resolvedPaths = {}\nfunction resolveSymlink (symlink, cb) {\n  validate('SF', arguments)\n  var cached = resolvedPaths[symlink]\n  if (cached) return cb(null, cached)\n\n  readLinkOrShim(symlink, iferr(cb, function (symlinkTarget) {\n    if (symlinkTarget) {\n      resolvedPaths[symlink] = path.resolve(path.dirname(symlink), symlinkTarget)\n    } else {\n      resolvedPaths[symlink] = symlink\n    }\n    return cb(null, resolvedPaths[symlink])\n  }))\n}\n\nexports._readLinkOrShim = readLinkOrShim\nfunction readLinkOrShim (path, cb) {\n  validate('SF', arguments)\n  fs.lstat(path, iferr(cb, function (stat) {\n    if (stat.isSymbolicLink()) {\n      fs.readlink(path, cb)\n    } else {\n      readCmdShim(path, function (er, source) {\n        if (!er) return cb(null, source)\n        // lstat wouldn't return an error on these, so we don't either.\n        if (er.code === 'ENOTASHIM' || er.code === 'EISDIR') {\n          return cb(null, null)\n        } else {\n          return cb(er)\n        }\n      })\n    }\n  }))\n}\n"]},"metadata":{},"sourceType":"script"}