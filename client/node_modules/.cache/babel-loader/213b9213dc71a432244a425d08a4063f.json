{"ast":null,"code":"'use strict';\n\nconst cacache = require('cacache');\n\nconst fetch = require('node-fetch-npm');\n\nconst pipe = require('mississippi').pipe;\n\nconst ssri = require('ssri');\n\nconst through = require('mississippi').through;\n\nconst to = require('mississippi').to;\n\nconst url = require('url');\n\nconst stream = require('stream');\n\nconst MAX_MEM_SIZE = 5 * 1024 * 1024; // 5MB\n\nfunction cacheKey(req) {\n  const parsed = url.parse(req.url);\n  return `make-fetch-happen:request-cache:${url.format({\n    protocol: parsed.protocol,\n    slashes: parsed.slashes,\n    host: parsed.host,\n    hostname: parsed.hostname,\n    pathname: parsed.pathname\n  })}`;\n} // This is a cacache-based implementation of the Cache standard,\n// using node-fetch.\n// docs: https://developer.mozilla.org/en-US/docs/Web/API/Cache\n//\n\n\nmodule.exports = class Cache {\n  constructor(path, opts) {\n    this._path = path;\n    this.Promise = opts && opts.Promise || Promise;\n  } // Returns a Promise that resolves to the response associated with the first\n  // matching request in the Cache object.\n\n\n  match(req, opts) {\n    opts = opts || {};\n    const key = cacheKey(req);\n    return cacache.get.info(this._path, key).then(info => {\n      return info && cacache.get.hasContent(this._path, info.integrity, opts).then(exists => exists && info);\n    }).then(info => {\n      if (info && info.metadata && matchDetails(req, {\n        url: info.metadata.url,\n        reqHeaders: new fetch.Headers(info.metadata.reqHeaders),\n        resHeaders: new fetch.Headers(info.metadata.resHeaders),\n        cacheIntegrity: info.integrity,\n        integrity: opts && opts.integrity\n      })) {\n        const resHeaders = new fetch.Headers(info.metadata.resHeaders);\n        addCacheHeaders(resHeaders, this._path, key, info.integrity, info.time);\n\n        if (req.method === 'HEAD') {\n          return new fetch.Response(null, {\n            url: req.url,\n            headers: resHeaders,\n            status: 200\n          });\n        }\n\n        let body;\n        const cachePath = this._path; // avoid opening cache file handles until a user actually tries to\n        // read from it.\n\n        if (opts.memoize !== false && info.size > MAX_MEM_SIZE) {\n          body = new stream.PassThrough();\n          const realRead = body._read;\n\n          body._read = function (size) {\n            body._read = realRead;\n            pipe(cacache.get.stream.byDigest(cachePath, info.integrity, {\n              memoize: opts.memoize\n            }), body, err => body.emit(err));\n            return realRead.call(this, size);\n          };\n        } else {\n          let readOnce = false; // cacache is much faster at bulk reads\n\n          body = new stream.Readable({\n            read() {\n              if (readOnce) return this.push(null);\n              readOnce = true;\n              cacache.get.byDigest(cachePath, info.integrity, {\n                memoize: opts.memoize\n              }).then(data => {\n                this.push(data);\n                this.push(null);\n              }, err => this.emit('error', err));\n            }\n\n          });\n        }\n\n        return this.Promise.resolve(new fetch.Response(body, {\n          url: req.url,\n          headers: resHeaders,\n          status: 200,\n          size: info.size\n        }));\n      }\n    });\n  } // Takes both a request and its response and adds it to the given cache.\n\n\n  put(req, response, opts) {\n    opts = opts || {};\n    const size = response.headers.get('content-length');\n    const fitInMemory = !!size && opts.memoize !== false && size < MAX_MEM_SIZE;\n    const ckey = cacheKey(req);\n    const cacheOpts = {\n      algorithms: opts.algorithms,\n      metadata: {\n        url: req.url,\n        reqHeaders: req.headers.raw(),\n        resHeaders: response.headers.raw()\n      },\n      size,\n      memoize: fitInMemory && opts.memoize\n    };\n\n    if (req.method === 'HEAD' || response.status === 304) {\n      // Update metadata without writing\n      return cacache.get.info(this._path, ckey).then(info => {\n        // Providing these will bypass content write\n        cacheOpts.integrity = info.integrity;\n        addCacheHeaders(response.headers, this._path, ckey, info.integrity, info.time);\n        return new this.Promise((resolve, reject) => {\n          pipe(cacache.get.stream.byDigest(this._path, info.integrity, cacheOpts), cacache.put.stream(this._path, cacheKey(req), cacheOpts), err => err ? reject(err) : resolve(response));\n        });\n      }).then(() => response);\n    }\n\n    let buf = [];\n    let bufSize = 0;\n    let cacheTargetStream = false;\n    const cachePath = this._path;\n    let cacheStream = to((chunk, enc, cb) => {\n      if (!cacheTargetStream) {\n        if (fitInMemory) {\n          cacheTargetStream = to({\n            highWaterMark: MAX_MEM_SIZE\n          }, (chunk, enc, cb) => {\n            buf.push(chunk);\n            bufSize += chunk.length;\n            cb();\n          }, done => {\n            cacache.put(cachePath, cacheKey(req), Buffer.concat(buf, bufSize), cacheOpts).then(() => done(), done);\n          });\n        } else {\n          cacheTargetStream = cacache.put.stream(cachePath, cacheKey(req), cacheOpts);\n        }\n      }\n\n      cacheTargetStream.write(chunk, enc, cb);\n    }, done => {\n      cacheTargetStream ? cacheTargetStream.end(done) : done();\n    });\n    const oldBody = response.body;\n    const newBody = through({\n      highWaterMark: MAX_MEM_SIZE\n    });\n    response.body = newBody;\n    oldBody.once('error', err => newBody.emit('error', err));\n    newBody.once('error', err => oldBody.emit('error', err));\n    cacheStream.once('error', err => newBody.emit('error', err));\n    pipe(oldBody, to((chunk, enc, cb) => {\n      cacheStream.write(chunk, enc, () => {\n        newBody.write(chunk, enc, cb);\n      });\n    }, done => {\n      cacheStream.end(() => {\n        newBody.end(() => {\n          done();\n        });\n      });\n    }), err => err && newBody.emit('error', err));\n    return response;\n  } // Finds the Cache entry whose key is the request, and if found, deletes the\n  // Cache entry and returns a Promise that resolves to true. If no Cache entry\n  // is found, it returns false.\n\n\n  'delete'(req, opts) {\n    opts = opts || {};\n\n    if (typeof opts.memoize === 'object') {\n      if (opts.memoize.reset) {\n        opts.memoize.reset();\n      } else if (opts.memoize.clear) {\n        opts.memoize.clear();\n      } else {\n        Object.keys(opts.memoize).forEach(k => {\n          opts.memoize[k] = null;\n        });\n      }\n    }\n\n    return cacache.rm.entry(this._path, cacheKey(req) // TODO - true/false\n    ).then(() => false);\n  }\n\n};\n\nfunction matchDetails(req, cached) {\n  const reqUrl = url.parse(req.url);\n  const cacheUrl = url.parse(cached.url);\n  const vary = cached.resHeaders.get('Vary'); // https://tools.ietf.org/html/rfc7234#section-4.1\n\n  if (vary) {\n    if (vary.match(/\\*/)) {\n      return false;\n    } else {\n      const fieldsMatch = vary.split(/\\s*,\\s*/).every(field => {\n        return cached.reqHeaders.get(field) === req.headers.get(field);\n      });\n\n      if (!fieldsMatch) {\n        return false;\n      }\n    }\n  }\n\n  if (cached.integrity) {\n    return ssri.parse(cached.integrity).match(cached.cacheIntegrity);\n  }\n\n  reqUrl.hash = null;\n  cacheUrl.hash = null;\n  return url.format(reqUrl) === url.format(cacheUrl);\n}\n\nfunction addCacheHeaders(resHeaders, path, key, hash, time) {\n  resHeaders.set('X-Local-Cache', encodeURIComponent(path));\n  resHeaders.set('X-Local-Cache-Key', encodeURIComponent(key));\n  resHeaders.set('X-Local-Cache-Hash', encodeURIComponent(hash));\n  resHeaders.set('X-Local-Cache-Time', new Date(time).toUTCString());\n}","map":{"version":3,"sources":["/Users/moonbox/Documents/capstone/pantrypal/node_modules/npm/node_modules/make-fetch-happen/cache.js"],"names":["cacache","require","fetch","pipe","ssri","through","to","url","stream","MAX_MEM_SIZE","cacheKey","req","parsed","parse","format","protocol","slashes","host","hostname","pathname","module","exports","Cache","constructor","path","opts","_path","Promise","match","key","get","info","then","hasContent","integrity","exists","metadata","matchDetails","reqHeaders","Headers","resHeaders","cacheIntegrity","addCacheHeaders","time","method","Response","headers","status","body","cachePath","memoize","size","PassThrough","realRead","_read","byDigest","err","emit","call","readOnce","Readable","read","push","data","resolve","put","response","fitInMemory","ckey","cacheOpts","algorithms","raw","reject","buf","bufSize","cacheTargetStream","cacheStream","chunk","enc","cb","highWaterMark","length","done","Buffer","concat","write","end","oldBody","newBody","once","reset","clear","Object","keys","forEach","k","rm","entry","cached","reqUrl","cacheUrl","vary","fieldsMatch","split","every","field","hash","set","encodeURIComponent","Date","toUTCString"],"mappings":"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","sourcesContent":["'use strict'\n\nconst cacache = require('cacache')\nconst fetch = require('node-fetch-npm')\nconst pipe = require('mississippi').pipe\nconst ssri = require('ssri')\nconst through = require('mississippi').through\nconst to = require('mississippi').to\nconst url = require('url')\nconst stream = require('stream')\n\nconst MAX_MEM_SIZE = 5 * 1024 * 1024 // 5MB\n\nfunction cacheKey (req) {\n  const parsed = url.parse(req.url)\n  return `make-fetch-happen:request-cache:${\n    url.format({\n      protocol: parsed.protocol,\n      slashes: parsed.slashes,\n      host: parsed.host,\n      hostname: parsed.hostname,\n      pathname: parsed.pathname\n    })\n  }`\n}\n\n// This is a cacache-based implementation of the Cache standard,\n// using node-fetch.\n// docs: https://developer.mozilla.org/en-US/docs/Web/API/Cache\n//\nmodule.exports = class Cache {\n  constructor (path, opts) {\n    this._path = path\n    this.Promise = (opts && opts.Promise) || Promise\n  }\n\n  // Returns a Promise that resolves to the response associated with the first\n  // matching request in the Cache object.\n  match (req, opts) {\n    opts = opts || {}\n    const key = cacheKey(req)\n    return cacache.get.info(this._path, key).then(info => {\n      return info && cacache.get.hasContent(\n        this._path, info.integrity, opts\n      ).then(exists => exists && info)\n    }).then(info => {\n      if (info && info.metadata && matchDetails(req, {\n        url: info.metadata.url,\n        reqHeaders: new fetch.Headers(info.metadata.reqHeaders),\n        resHeaders: new fetch.Headers(info.metadata.resHeaders),\n        cacheIntegrity: info.integrity,\n        integrity: opts && opts.integrity\n      })) {\n        const resHeaders = new fetch.Headers(info.metadata.resHeaders)\n        addCacheHeaders(resHeaders, this._path, key, info.integrity, info.time)\n        if (req.method === 'HEAD') {\n          return new fetch.Response(null, {\n            url: req.url,\n            headers: resHeaders,\n            status: 200\n          })\n        }\n        let body\n        const cachePath = this._path\n        // avoid opening cache file handles until a user actually tries to\n        // read from it.\n        if (opts.memoize !== false && info.size > MAX_MEM_SIZE) {\n          body = new stream.PassThrough()\n          const realRead = body._read\n          body._read = function (size) {\n            body._read = realRead\n            pipe(\n              cacache.get.stream.byDigest(cachePath, info.integrity, {\n                memoize: opts.memoize\n              }),\n              body,\n              err => body.emit(err))\n            return realRead.call(this, size)\n          }\n        } else {\n          let readOnce = false\n          // cacache is much faster at bulk reads\n          body = new stream.Readable({\n            read () {\n              if (readOnce) return this.push(null)\n              readOnce = true\n              cacache.get.byDigest(cachePath, info.integrity, {\n                memoize: opts.memoize\n              }).then(data => {\n                this.push(data)\n                this.push(null)\n              }, err => this.emit('error', err))\n            }\n          })\n        }\n        return this.Promise.resolve(new fetch.Response(body, {\n          url: req.url,\n          headers: resHeaders,\n          status: 200,\n          size: info.size\n        }))\n      }\n    })\n  }\n\n  // Takes both a request and its response and adds it to the given cache.\n  put (req, response, opts) {\n    opts = opts || {}\n    const size = response.headers.get('content-length')\n    const fitInMemory = !!size && opts.memoize !== false && size < MAX_MEM_SIZE\n    const ckey = cacheKey(req)\n    const cacheOpts = {\n      algorithms: opts.algorithms,\n      metadata: {\n        url: req.url,\n        reqHeaders: req.headers.raw(),\n        resHeaders: response.headers.raw()\n      },\n      size,\n      memoize: fitInMemory && opts.memoize\n    }\n    if (req.method === 'HEAD' || response.status === 304) {\n      // Update metadata without writing\n      return cacache.get.info(this._path, ckey).then(info => {\n        // Providing these will bypass content write\n        cacheOpts.integrity = info.integrity\n        addCacheHeaders(\n          response.headers, this._path, ckey, info.integrity, info.time\n        )\n        return new this.Promise((resolve, reject) => {\n          pipe(\n            cacache.get.stream.byDigest(this._path, info.integrity, cacheOpts),\n            cacache.put.stream(this._path, cacheKey(req), cacheOpts),\n            err => err ? reject(err) : resolve(response)\n          )\n        })\n      }).then(() => response)\n    }\n    let buf = []\n    let bufSize = 0\n    let cacheTargetStream = false\n    const cachePath = this._path\n    let cacheStream = to((chunk, enc, cb) => {\n      if (!cacheTargetStream) {\n        if (fitInMemory) {\n          cacheTargetStream =\n          to({highWaterMark: MAX_MEM_SIZE}, (chunk, enc, cb) => {\n            buf.push(chunk)\n            bufSize += chunk.length\n            cb()\n          }, done => {\n            cacache.put(\n              cachePath,\n              cacheKey(req),\n              Buffer.concat(buf, bufSize),\n              cacheOpts\n            ).then(\n              () => done(),\n              done\n            )\n          })\n        } else {\n          cacheTargetStream =\n          cacache.put.stream(cachePath, cacheKey(req), cacheOpts)\n        }\n      }\n      cacheTargetStream.write(chunk, enc, cb)\n    }, done => {\n      cacheTargetStream ? cacheTargetStream.end(done) : done()\n    })\n    const oldBody = response.body\n    const newBody = through({highWaterMark: MAX_MEM_SIZE})\n    response.body = newBody\n    oldBody.once('error', err => newBody.emit('error', err))\n    newBody.once('error', err => oldBody.emit('error', err))\n    cacheStream.once('error', err => newBody.emit('error', err))\n    pipe(oldBody, to((chunk, enc, cb) => {\n      cacheStream.write(chunk, enc, () => {\n        newBody.write(chunk, enc, cb)\n      })\n    }, done => {\n      cacheStream.end(() => {\n        newBody.end(() => {\n          done()\n        })\n      })\n    }), err => err && newBody.emit('error', err))\n    return response\n  }\n\n  // Finds the Cache entry whose key is the request, and if found, deletes the\n  // Cache entry and returns a Promise that resolves to true. If no Cache entry\n  // is found, it returns false.\n  'delete' (req, opts) {\n    opts = opts || {}\n    if (typeof opts.memoize === 'object') {\n      if (opts.memoize.reset) {\n        opts.memoize.reset()\n      } else if (opts.memoize.clear) {\n        opts.memoize.clear()\n      } else {\n        Object.keys(opts.memoize).forEach(k => {\n          opts.memoize[k] = null\n        })\n      }\n    }\n    return cacache.rm.entry(\n      this._path,\n      cacheKey(req)\n    // TODO - true/false\n    ).then(() => false)\n  }\n}\n\nfunction matchDetails (req, cached) {\n  const reqUrl = url.parse(req.url)\n  const cacheUrl = url.parse(cached.url)\n  const vary = cached.resHeaders.get('Vary')\n  // https://tools.ietf.org/html/rfc7234#section-4.1\n  if (vary) {\n    if (vary.match(/\\*/)) {\n      return false\n    } else {\n      const fieldsMatch = vary.split(/\\s*,\\s*/).every(field => {\n        return cached.reqHeaders.get(field) === req.headers.get(field)\n      })\n      if (!fieldsMatch) {\n        return false\n      }\n    }\n  }\n  if (cached.integrity) {\n    return ssri.parse(cached.integrity).match(cached.cacheIntegrity)\n  }\n  reqUrl.hash = null\n  cacheUrl.hash = null\n  return url.format(reqUrl) === url.format(cacheUrl)\n}\n\nfunction addCacheHeaders (resHeaders, path, key, hash, time) {\n  resHeaders.set('X-Local-Cache', encodeURIComponent(path))\n  resHeaders.set('X-Local-Cache-Key', encodeURIComponent(key))\n  resHeaders.set('X-Local-Cache-Hash', encodeURIComponent(hash))\n  resHeaders.set('X-Local-Cache-Time', new Date(time).toUTCString())\n}\n"]},"metadata":{},"sourceType":"script"}