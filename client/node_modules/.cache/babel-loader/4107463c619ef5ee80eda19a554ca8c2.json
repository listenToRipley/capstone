{"ast":null,"code":"'use strict';\n\nconst LRU = require('lru-cache');\n\nconst url = require('url');\n\nlet AGENT_CACHE = new LRU({\n  max: 50\n});\nlet HttpsAgent;\nlet HttpAgent;\nmodule.exports = getAgent;\n\nfunction getAgent(uri, opts) {\n  const parsedUri = url.parse(typeof uri === 'string' ? uri : uri.url);\n  const isHttps = parsedUri.protocol === 'https:';\n  const pxuri = getProxyUri(uri, opts);\n  const key = [`https:${isHttps}`, pxuri ? `proxy:${pxuri.protocol}//${pxuri.host}:${pxuri.port}` : '>no-proxy<', `local-address:${opts.localAddress || '>no-local-address<'}`, `strict-ssl:${isHttps ? !!opts.strictSSL : '>no-strict-ssl<'}`, `ca:${isHttps && opts.ca || '>no-ca<'}`, `cert:${isHttps && opts.cert || '>no-cert<'}`, `key:${isHttps && opts.key || '>no-key<'}`].join(':');\n\n  if (opts.agent != null) {\n    // `agent: false` has special behavior!\n    return opts.agent;\n  }\n\n  if (AGENT_CACHE.peek(key)) {\n    return AGENT_CACHE.get(key);\n  }\n\n  if (pxuri) {\n    const proxy = getProxy(pxuri, opts, isHttps);\n    AGENT_CACHE.set(key, proxy);\n    return proxy;\n  }\n\n  if (isHttps && !HttpsAgent) {\n    HttpsAgent = require('agentkeepalive').HttpsAgent;\n  } else if (!isHttps && !HttpAgent) {\n    HttpAgent = require('agentkeepalive');\n  } // If opts.timeout is zero, set the agentTimeout to zero as well. A timeout\n  // of zero disables the timeout behavior (OS limits still apply). Else, if\n  // opts.timeout is a non-zero value, set it to timeout + 1, to ensure that\n  // the node-fetch-npm timeout will always fire first, giving us more\n  // consistent errors.\n\n\n  const agentTimeout = opts.timeout === 0 ? 0 : opts.timeout + 1;\n  const agent = isHttps ? new HttpsAgent({\n    maxSockets: opts.maxSockets || 15,\n    ca: opts.ca,\n    cert: opts.cert,\n    key: opts.key,\n    localAddress: opts.localAddress,\n    rejectUnauthorized: opts.strictSSL,\n    timeout: agentTimeout\n  }) : new HttpAgent({\n    maxSockets: opts.maxSockets || 15,\n    localAddress: opts.localAddress,\n    timeout: agentTimeout\n  });\n  AGENT_CACHE.set(key, agent);\n  return agent;\n}\n\nfunction checkNoProxy(uri, opts) {\n  const host = url.parse(uri).hostname.split('.').reverse();\n  let noproxy = opts.noProxy || getProcessEnv('no_proxy');\n\n  if (typeof noproxy === 'string') {\n    noproxy = noproxy.split(/\\s*,\\s*/g);\n  }\n\n  return noproxy && noproxy.some(no => {\n    const noParts = no.split('.').filter(x => x).reverse();\n\n    if (!noParts.length) {\n      return false;\n    }\n\n    for (let i = 0; i < noParts.length; i++) {\n      if (host[i] !== noParts[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  });\n}\n\nmodule.exports.getProcessEnv = getProcessEnv;\n\nfunction getProcessEnv(env) {\n  if (!env) {\n    return;\n  }\n\n  let value;\n\n  if (Array.isArray(env)) {\n    for (let e of env) {\n      value = process.env[e] || process.env[e.toUpperCase()] || process.env[e.toLowerCase()];\n\n      if (typeof value !== 'undefined') {\n        break;\n      }\n    }\n  }\n\n  if (typeof env === 'string') {\n    value = process.env[env] || process.env[env.toUpperCase()] || process.env[env.toLowerCase()];\n  }\n\n  return value;\n}\n\nfunction getProxyUri(uri, opts) {\n  const protocol = url.parse(uri).protocol;\n  const proxy = opts.proxy || protocol === 'https:' && getProcessEnv('https_proxy') || protocol === 'http:' && getProcessEnv(['https_proxy', 'http_proxy', 'proxy']);\n\n  if (!proxy) {\n    return null;\n  }\n\n  const parsedProxy = typeof proxy === 'string' ? url.parse(proxy) : proxy;\n  return !checkNoProxy(uri, opts) && parsedProxy;\n}\n\nlet HttpProxyAgent;\nlet HttpsProxyAgent;\nlet SocksProxyAgent;\n\nfunction getProxy(proxyUrl, opts, isHttps) {\n  let popts = {\n    host: proxyUrl.hostname,\n    port: proxyUrl.port,\n    protocol: proxyUrl.protocol,\n    path: proxyUrl.path,\n    auth: proxyUrl.auth,\n    ca: opts.ca,\n    cert: opts.cert,\n    key: opts.key,\n    timeout: opts.timeout === 0 ? 0 : opts.timeout + 1,\n    localAddress: opts.localAddress,\n    maxSockets: opts.maxSockets || 15,\n    rejectUnauthorized: opts.strictSSL\n  };\n\n  if (proxyUrl.protocol === 'http:' || proxyUrl.protocol === 'https:') {\n    if (!isHttps) {\n      if (!HttpProxyAgent) {\n        HttpProxyAgent = require('http-proxy-agent');\n      }\n\n      return new HttpProxyAgent(popts);\n    } else {\n      if (!HttpsProxyAgent) {\n        HttpsProxyAgent = require('https-proxy-agent');\n      }\n\n      return new HttpsProxyAgent(popts);\n    }\n  }\n\n  if (proxyUrl.protocol.startsWith('socks')) {\n    if (!SocksProxyAgent) {\n      SocksProxyAgent = require('socks-proxy-agent');\n    }\n\n    return new SocksProxyAgent(popts);\n  }\n}","map":{"version":3,"sources":["/Users/moonbox/Documents/capstone/pantrypal/node_modules/npm/node_modules/make-fetch-happen/agent.js"],"names":["LRU","require","url","AGENT_CACHE","max","HttpsAgent","HttpAgent","module","exports","getAgent","uri","opts","parsedUri","parse","isHttps","protocol","pxuri","getProxyUri","key","host","port","localAddress","strictSSL","ca","cert","join","agent","peek","get","proxy","getProxy","set","agentTimeout","timeout","maxSockets","rejectUnauthorized","checkNoProxy","hostname","split","reverse","noproxy","noProxy","getProcessEnv","some","no","noParts","filter","x","length","i","env","value","Array","isArray","e","process","toUpperCase","toLowerCase","parsedProxy","HttpProxyAgent","HttpsProxyAgent","SocksProxyAgent","proxyUrl","popts","path","auth","startsWith"],"mappings":"AAAA;;AACA,MAAMA,GAAG,GAAGC,OAAO,CAAC,WAAD,CAAnB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,KAAD,CAAnB;;AAEA,IAAIE,WAAW,GAAG,IAAIH,GAAJ,CAAQ;AAAEI,EAAAA,GAAG,EAAE;AAAP,CAAR,CAAlB;AACA,IAAIC,UAAJ;AACA,IAAIC,SAAJ;AAEAC,MAAM,CAACC,OAAP,GAAiBC,QAAjB;;AAEA,SAASA,QAAT,CAAmBC,GAAnB,EAAwBC,IAAxB,EAA8B;AAC5B,QAAMC,SAAS,GAAGV,GAAG,CAACW,KAAJ,CAAU,OAAOH,GAAP,KAAe,QAAf,GAA0BA,GAA1B,GAAgCA,GAAG,CAACR,GAA9C,CAAlB;AACA,QAAMY,OAAO,GAAGF,SAAS,CAACG,QAAV,KAAuB,QAAvC;AACA,QAAMC,KAAK,GAAGC,WAAW,CAACP,GAAD,EAAMC,IAAN,CAAzB;AAEA,QAAMO,GAAG,GAAG,CACT,SAAQJ,OAAQ,EADP,EAEVE,KAAK,GACA,SAAQA,KAAK,CAACD,QAAS,KAAIC,KAAK,CAACG,IAAK,IAAGH,KAAK,CAACI,IAAK,EADpD,GAED,YAJM,EAKT,iBAAgBT,IAAI,CAACU,YAAL,IAAqB,oBAAqB,EALjD,EAMT,cAAaP,OAAO,GAAG,CAAC,CAACH,IAAI,CAACW,SAAV,GAAsB,iBAAkB,EANnD,EAOT,MAAMR,OAAO,IAAIH,IAAI,CAACY,EAAjB,IAAwB,SAAU,EAP9B,EAQT,QAAQT,OAAO,IAAIH,IAAI,CAACa,IAAjB,IAA0B,WAAY,EARpC,EAST,OAAOV,OAAO,IAAIH,IAAI,CAACO,GAAjB,IAAyB,UAAW,EATjC,EAUVO,IAVU,CAUL,GAVK,CAAZ;;AAYA,MAAId,IAAI,CAACe,KAAL,IAAc,IAAlB,EAAwB;AAAE;AACxB,WAAOf,IAAI,CAACe,KAAZ;AACD;;AAED,MAAIvB,WAAW,CAACwB,IAAZ,CAAiBT,GAAjB,CAAJ,EAA2B;AACzB,WAAOf,WAAW,CAACyB,GAAZ,CAAgBV,GAAhB,CAAP;AACD;;AAED,MAAIF,KAAJ,EAAW;AACT,UAAMa,KAAK,GAAGC,QAAQ,CAACd,KAAD,EAAQL,IAAR,EAAcG,OAAd,CAAtB;AACAX,IAAAA,WAAW,CAAC4B,GAAZ,CAAgBb,GAAhB,EAAqBW,KAArB;AACA,WAAOA,KAAP;AACD;;AAED,MAAIf,OAAO,IAAI,CAACT,UAAhB,EAA4B;AAC1BA,IAAAA,UAAU,GAAGJ,OAAO,CAAC,gBAAD,CAAP,CAA0BI,UAAvC;AACD,GAFD,MAEO,IAAI,CAACS,OAAD,IAAY,CAACR,SAAjB,EAA4B;AACjCA,IAAAA,SAAS,GAAGL,OAAO,CAAC,gBAAD,CAAnB;AACD,GAnC2B,CAqC5B;AACA;AACA;AACA;AACA;;;AACA,QAAM+B,YAAY,GAAGrB,IAAI,CAACsB,OAAL,KAAiB,CAAjB,GAAqB,CAArB,GAAyBtB,IAAI,CAACsB,OAAL,GAAe,CAA7D;AAEA,QAAMP,KAAK,GAAGZ,OAAO,GAAG,IAAIT,UAAJ,CAAe;AACrC6B,IAAAA,UAAU,EAAEvB,IAAI,CAACuB,UAAL,IAAmB,EADM;AAErCX,IAAAA,EAAE,EAAEZ,IAAI,CAACY,EAF4B;AAGrCC,IAAAA,IAAI,EAAEb,IAAI,CAACa,IAH0B;AAIrCN,IAAAA,GAAG,EAAEP,IAAI,CAACO,GAJ2B;AAKrCG,IAAAA,YAAY,EAAEV,IAAI,CAACU,YALkB;AAMrCc,IAAAA,kBAAkB,EAAExB,IAAI,CAACW,SANY;AAOrCW,IAAAA,OAAO,EAAED;AAP4B,GAAf,CAAH,GAQhB,IAAI1B,SAAJ,CAAc;AACjB4B,IAAAA,UAAU,EAAEvB,IAAI,CAACuB,UAAL,IAAmB,EADd;AAEjBb,IAAAA,YAAY,EAAEV,IAAI,CAACU,YAFF;AAGjBY,IAAAA,OAAO,EAAED;AAHQ,GAAd,CARL;AAaA7B,EAAAA,WAAW,CAAC4B,GAAZ,CAAgBb,GAAhB,EAAqBQ,KAArB;AACA,SAAOA,KAAP;AACD;;AAED,SAASU,YAAT,CAAuB1B,GAAvB,EAA4BC,IAA5B,EAAkC;AAChC,QAAMQ,IAAI,GAAGjB,GAAG,CAACW,KAAJ,CAAUH,GAAV,EAAe2B,QAAf,CAAwBC,KAAxB,CAA8B,GAA9B,EAAmCC,OAAnC,EAAb;AACA,MAAIC,OAAO,GAAI7B,IAAI,CAAC8B,OAAL,IAAgBC,aAAa,CAAC,UAAD,CAA5C;;AACA,MAAI,OAAOF,OAAP,KAAmB,QAAvB,EAAiC;AAC/BA,IAAAA,OAAO,GAAGA,OAAO,CAACF,KAAR,CAAc,UAAd,CAAV;AACD;;AACD,SAAOE,OAAO,IAAIA,OAAO,CAACG,IAAR,CAAaC,EAAE,IAAI;AACnC,UAAMC,OAAO,GAAGD,EAAE,CAACN,KAAH,CAAS,GAAT,EAAcQ,MAAd,CAAqBC,CAAC,IAAIA,CAA1B,EAA6BR,OAA7B,EAAhB;;AACA,QAAI,CAACM,OAAO,CAACG,MAAb,EAAqB;AAAE,aAAO,KAAP;AAAc;;AACrC,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,OAAO,CAACG,MAA5B,EAAoCC,CAAC,EAArC,EAAyC;AACvC,UAAI9B,IAAI,CAAC8B,CAAD,CAAJ,KAAYJ,OAAO,CAACI,CAAD,CAAvB,EAA4B;AAC1B,eAAO,KAAP;AACD;AACF;;AACD,WAAO,IAAP;AACD,GATiB,CAAlB;AAUD;;AAED1C,MAAM,CAACC,OAAP,CAAekC,aAAf,GAA+BA,aAA/B;;AAEA,SAASA,aAAT,CAAwBQ,GAAxB,EAA6B;AAC3B,MAAI,CAACA,GAAL,EAAU;AAAE;AAAQ;;AAEpB,MAAIC,KAAJ;;AAEA,MAAIC,KAAK,CAACC,OAAN,CAAcH,GAAd,CAAJ,EAAwB;AACtB,SAAK,IAAII,CAAT,IAAcJ,GAAd,EAAmB;AACjBC,MAAAA,KAAK,GAAGI,OAAO,CAACL,GAAR,CAAYI,CAAZ,KACNC,OAAO,CAACL,GAAR,CAAYI,CAAC,CAACE,WAAF,EAAZ,CADM,IAEND,OAAO,CAACL,GAAR,CAAYI,CAAC,CAACG,WAAF,EAAZ,CAFF;;AAGA,UAAI,OAAON,KAAP,KAAiB,WAArB,EAAkC;AAAE;AAAO;AAC5C;AACF;;AAED,MAAI,OAAOD,GAAP,KAAe,QAAnB,EAA6B;AAC3BC,IAAAA,KAAK,GAAGI,OAAO,CAACL,GAAR,CAAYA,GAAZ,KACNK,OAAO,CAACL,GAAR,CAAYA,GAAG,CAACM,WAAJ,EAAZ,CADM,IAEND,OAAO,CAACL,GAAR,CAAYA,GAAG,CAACO,WAAJ,EAAZ,CAFF;AAGD;;AAED,SAAON,KAAP;AACD;;AAED,SAASlC,WAAT,CAAsBP,GAAtB,EAA2BC,IAA3B,EAAiC;AAC/B,QAAMI,QAAQ,GAAGb,GAAG,CAACW,KAAJ,CAAUH,GAAV,EAAeK,QAAhC;AAEA,QAAMc,KAAK,GAAGlB,IAAI,CAACkB,KAAL,IACZd,QAAQ,KAAK,QAAb,IAAyB2B,aAAa,CAAC,aAAD,CAD1B,IAGV3B,QAAQ,KAAK,OAAb,IAAwB2B,aAAa,CAAC,CAAC,aAAD,EAAgB,YAAhB,EAA8B,OAA9B,CAAD,CAHzC;;AAKA,MAAI,CAACb,KAAL,EAAY;AAAE,WAAO,IAAP;AAAa;;AAE3B,QAAM6B,WAAW,GAAI,OAAO7B,KAAP,KAAiB,QAAlB,GAA8B3B,GAAG,CAACW,KAAJ,CAAUgB,KAAV,CAA9B,GAAiDA,KAArE;AAEA,SAAO,CAACO,YAAY,CAAC1B,GAAD,EAAMC,IAAN,CAAb,IAA4B+C,WAAnC;AACD;;AAED,IAAIC,cAAJ;AACA,IAAIC,eAAJ;AACA,IAAIC,eAAJ;;AACA,SAAS/B,QAAT,CAAmBgC,QAAnB,EAA6BnD,IAA7B,EAAmCG,OAAnC,EAA4C;AAC1C,MAAIiD,KAAK,GAAG;AACV5C,IAAAA,IAAI,EAAE2C,QAAQ,CAACzB,QADL;AAEVjB,IAAAA,IAAI,EAAE0C,QAAQ,CAAC1C,IAFL;AAGVL,IAAAA,QAAQ,EAAE+C,QAAQ,CAAC/C,QAHT;AAIViD,IAAAA,IAAI,EAAEF,QAAQ,CAACE,IAJL;AAKVC,IAAAA,IAAI,EAAEH,QAAQ,CAACG,IALL;AAMV1C,IAAAA,EAAE,EAAEZ,IAAI,CAACY,EANC;AAOVC,IAAAA,IAAI,EAAEb,IAAI,CAACa,IAPD;AAQVN,IAAAA,GAAG,EAAEP,IAAI,CAACO,GARA;AASVe,IAAAA,OAAO,EAAEtB,IAAI,CAACsB,OAAL,KAAiB,CAAjB,GAAqB,CAArB,GAAyBtB,IAAI,CAACsB,OAAL,GAAe,CATvC;AAUVZ,IAAAA,YAAY,EAAEV,IAAI,CAACU,YAVT;AAWVa,IAAAA,UAAU,EAAEvB,IAAI,CAACuB,UAAL,IAAmB,EAXrB;AAYVC,IAAAA,kBAAkB,EAAExB,IAAI,CAACW;AAZf,GAAZ;;AAeA,MAAIwC,QAAQ,CAAC/C,QAAT,KAAsB,OAAtB,IAAiC+C,QAAQ,CAAC/C,QAAT,KAAsB,QAA3D,EAAqE;AACnE,QAAI,CAACD,OAAL,EAAc;AACZ,UAAI,CAAC6C,cAAL,EAAqB;AACnBA,QAAAA,cAAc,GAAG1D,OAAO,CAAC,kBAAD,CAAxB;AACD;;AAED,aAAO,IAAI0D,cAAJ,CAAmBI,KAAnB,CAAP;AACD,KAND,MAMO;AACL,UAAI,CAACH,eAAL,EAAsB;AACpBA,QAAAA,eAAe,GAAG3D,OAAO,CAAC,mBAAD,CAAzB;AACD;;AAED,aAAO,IAAI2D,eAAJ,CAAoBG,KAApB,CAAP;AACD;AACF;;AACD,MAAID,QAAQ,CAAC/C,QAAT,CAAkBmD,UAAlB,CAA6B,OAA7B,CAAJ,EAA2C;AACzC,QAAI,CAACL,eAAL,EAAsB;AACpBA,MAAAA,eAAe,GAAG5D,OAAO,CAAC,mBAAD,CAAzB;AACD;;AAED,WAAO,IAAI4D,eAAJ,CAAoBE,KAApB,CAAP;AACD;AACF","sourcesContent":["'use strict'\nconst LRU = require('lru-cache')\nconst url = require('url')\n\nlet AGENT_CACHE = new LRU({ max: 50 })\nlet HttpsAgent\nlet HttpAgent\n\nmodule.exports = getAgent\n\nfunction getAgent (uri, opts) {\n  const parsedUri = url.parse(typeof uri === 'string' ? uri : uri.url)\n  const isHttps = parsedUri.protocol === 'https:'\n  const pxuri = getProxyUri(uri, opts)\n\n  const key = [\n    `https:${isHttps}`,\n    pxuri\n      ? `proxy:${pxuri.protocol}//${pxuri.host}:${pxuri.port}`\n      : '>no-proxy<',\n    `local-address:${opts.localAddress || '>no-local-address<'}`,\n    `strict-ssl:${isHttps ? !!opts.strictSSL : '>no-strict-ssl<'}`,\n    `ca:${(isHttps && opts.ca) || '>no-ca<'}`,\n    `cert:${(isHttps && opts.cert) || '>no-cert<'}`,\n    `key:${(isHttps && opts.key) || '>no-key<'}`\n  ].join(':')\n\n  if (opts.agent != null) { // `agent: false` has special behavior!\n    return opts.agent\n  }\n\n  if (AGENT_CACHE.peek(key)) {\n    return AGENT_CACHE.get(key)\n  }\n\n  if (pxuri) {\n    const proxy = getProxy(pxuri, opts, isHttps)\n    AGENT_CACHE.set(key, proxy)\n    return proxy\n  }\n\n  if (isHttps && !HttpsAgent) {\n    HttpsAgent = require('agentkeepalive').HttpsAgent\n  } else if (!isHttps && !HttpAgent) {\n    HttpAgent = require('agentkeepalive')\n  }\n\n  // If opts.timeout is zero, set the agentTimeout to zero as well. A timeout\n  // of zero disables the timeout behavior (OS limits still apply). Else, if\n  // opts.timeout is a non-zero value, set it to timeout + 1, to ensure that\n  // the node-fetch-npm timeout will always fire first, giving us more\n  // consistent errors.\n  const agentTimeout = opts.timeout === 0 ? 0 : opts.timeout + 1\n\n  const agent = isHttps ? new HttpsAgent({\n    maxSockets: opts.maxSockets || 15,\n    ca: opts.ca,\n    cert: opts.cert,\n    key: opts.key,\n    localAddress: opts.localAddress,\n    rejectUnauthorized: opts.strictSSL,\n    timeout: agentTimeout\n  }) : new HttpAgent({\n    maxSockets: opts.maxSockets || 15,\n    localAddress: opts.localAddress,\n    timeout: agentTimeout\n  })\n  AGENT_CACHE.set(key, agent)\n  return agent\n}\n\nfunction checkNoProxy (uri, opts) {\n  const host = url.parse(uri).hostname.split('.').reverse()\n  let noproxy = (opts.noProxy || getProcessEnv('no_proxy'))\n  if (typeof noproxy === 'string') {\n    noproxy = noproxy.split(/\\s*,\\s*/g)\n  }\n  return noproxy && noproxy.some(no => {\n    const noParts = no.split('.').filter(x => x).reverse()\n    if (!noParts.length) { return false }\n    for (let i = 0; i < noParts.length; i++) {\n      if (host[i] !== noParts[i]) {\n        return false\n      }\n    }\n    return true\n  })\n}\n\nmodule.exports.getProcessEnv = getProcessEnv\n\nfunction getProcessEnv (env) {\n  if (!env) { return }\n\n  let value\n\n  if (Array.isArray(env)) {\n    for (let e of env) {\n      value = process.env[e] ||\n        process.env[e.toUpperCase()] ||\n        process.env[e.toLowerCase()]\n      if (typeof value !== 'undefined') { break }\n    }\n  }\n\n  if (typeof env === 'string') {\n    value = process.env[env] ||\n      process.env[env.toUpperCase()] ||\n      process.env[env.toLowerCase()]\n  }\n\n  return value\n}\n\nfunction getProxyUri (uri, opts) {\n  const protocol = url.parse(uri).protocol\n\n  const proxy = opts.proxy || (\n    protocol === 'https:' && getProcessEnv('https_proxy')\n  ) || (\n      protocol === 'http:' && getProcessEnv(['https_proxy', 'http_proxy', 'proxy'])\n    )\n  if (!proxy) { return null }\n\n  const parsedProxy = (typeof proxy === 'string') ? url.parse(proxy) : proxy\n\n  return !checkNoProxy(uri, opts) && parsedProxy\n}\n\nlet HttpProxyAgent\nlet HttpsProxyAgent\nlet SocksProxyAgent\nfunction getProxy (proxyUrl, opts, isHttps) {\n  let popts = {\n    host: proxyUrl.hostname,\n    port: proxyUrl.port,\n    protocol: proxyUrl.protocol,\n    path: proxyUrl.path,\n    auth: proxyUrl.auth,\n    ca: opts.ca,\n    cert: opts.cert,\n    key: opts.key,\n    timeout: opts.timeout === 0 ? 0 : opts.timeout + 1,\n    localAddress: opts.localAddress,\n    maxSockets: opts.maxSockets || 15,\n    rejectUnauthorized: opts.strictSSL\n  }\n\n  if (proxyUrl.protocol === 'http:' || proxyUrl.protocol === 'https:') {\n    if (!isHttps) {\n      if (!HttpProxyAgent) {\n        HttpProxyAgent = require('http-proxy-agent')\n      }\n\n      return new HttpProxyAgent(popts)\n    } else {\n      if (!HttpsProxyAgent) {\n        HttpsProxyAgent = require('https-proxy-agent')\n      }\n\n      return new HttpsProxyAgent(popts)\n    }\n  }\n  if (proxyUrl.protocol.startsWith('socks')) {\n    if (!SocksProxyAgent) {\n      SocksProxyAgent = require('socks-proxy-agent')\n    }\n\n    return new SocksProxyAgent(popts)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}