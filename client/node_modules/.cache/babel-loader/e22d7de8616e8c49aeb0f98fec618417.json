{"ast":null,"code":"'use strict';\n/**\n * index.js\n *\n * a request API compatible with window.fetch\n */\n\nconst url = require('url');\n\nconst http = require('http');\n\nconst https = require('https');\n\nconst zlib = require('zlib');\n\nconst PassThrough = require('stream').PassThrough;\n\nconst Body = require('./body.js');\n\nconst writeToStream = Body.writeToStream;\n\nconst Response = require('./response');\n\nconst Headers = require('./headers');\n\nconst Request = require('./request');\n\nconst getNodeRequestOptions = Request.getNodeRequestOptions;\n\nconst FetchError = require('./fetch-error');\n\nconst isURL = /^https?:/;\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\n\nexports = module.exports = fetch;\n\nfunction fetch(uri, opts) {\n  // allow custom promise\n  if (!fetch.Promise) {\n    throw new Error('native promise missing, set fetch.Promise to your favorite alternative');\n  }\n\n  Body.Promise = fetch.Promise; // wrap http.request into fetch\n\n  return new fetch.Promise((resolve, reject) => {\n    // build request object\n    const request = new Request(uri, opts);\n    const options = getNodeRequestOptions(request);\n    const send = (options.protocol === 'https:' ? https : http).request; // http.request only support string as host header, this hack make custom host header possible\n\n    if (options.headers.host) {\n      options.headers.host = options.headers.host[0];\n    } // send request\n\n\n    const req = send(options);\n    let reqTimeout;\n\n    if (request.timeout) {\n      req.once('socket', socket => {\n        reqTimeout = setTimeout(() => {\n          req.abort();\n          reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n        }, request.timeout);\n      });\n    }\n\n    req.on('error', err => {\n      clearTimeout(reqTimeout);\n      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n    });\n    req.on('response', res => {\n      clearTimeout(reqTimeout); // handle redirect\n\n      if (fetch.isRedirect(res.statusCode) && request.redirect !== 'manual') {\n        if (request.redirect === 'error') {\n          reject(new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect'));\n          return;\n        }\n\n        if (request.counter >= request.follow) {\n          reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n          return;\n        }\n\n        if (!res.headers.location) {\n          reject(new FetchError(`redirect location header missing at: ${request.url}`, 'invalid-redirect'));\n          return;\n        } // Remove authorization if changing hostnames (but not if just\n        // changing ports or protocols).  This matches the behavior of request:\n        // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n\n\n        const resolvedUrl = url.resolve(request.url, res.headers.location);\n        let redirectURL = '';\n\n        if (!isURL.test(res.headers.location)) {\n          redirectURL = url.parse(resolvedUrl);\n        } else {\n          redirectURL = url.parse(res.headers.location);\n        }\n\n        if (url.parse(request.url).hostname !== redirectURL.hostname) {\n          request.headers.delete('authorization');\n        } // per fetch spec, for POST request with 301/302 response, or any request with 303 response, use GET when following redirect\n\n\n        if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n          request.method = 'GET';\n          request.body = null;\n          request.headers.delete('content-length');\n        }\n\n        request.counter++;\n        resolve(fetch(resolvedUrl, request));\n        return;\n      } // normalize location header for manual redirect mode\n\n\n      const headers = new Headers();\n\n      for (const name of Object.keys(res.headers)) {\n        if (Array.isArray(res.headers[name])) {\n          for (const val of res.headers[name]) {\n            headers.append(name, val);\n          }\n        } else {\n          headers.append(name, res.headers[name]);\n        }\n      }\n\n      if (request.redirect === 'manual' && headers.has('location')) {\n        headers.set('location', url.resolve(request.url, headers.get('location')));\n      } // prepare response\n\n\n      let body = res.pipe(new PassThrough());\n      const responseOptions = {\n        url: request.url,\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: headers,\n        size: request.size,\n        timeout: request.timeout\n      }; // HTTP-network fetch step 16.1.2\n\n      const codings = headers.get('Content-Encoding'); // HTTP-network fetch step 16.1.3: handle content codings\n      // in following scenarios we ignore compression support\n      // 1. compression support is disabled\n      // 2. HEAD request\n      // 3. no Content-Encoding header\n      // 4. no content response (204)\n      // 5. content not modified response (304)\n\n      if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n        resolve(new Response(body, responseOptions));\n        return;\n      } // Be less strict when decoding compressed responses, since sometimes\n      // servers send slightly invalid responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n\n\n      const zlibOptions = {\n        flush: zlib.Z_SYNC_FLUSH,\n        finishFlush: zlib.Z_SYNC_FLUSH\n      }; // for gzip\n\n      if (codings === 'gzip' || codings === 'x-gzip') {\n        body = body.pipe(zlib.createGunzip(zlibOptions));\n        resolve(new Response(body, responseOptions));\n        return;\n      } // for deflate\n\n\n      if (codings === 'deflate' || codings === 'x-deflate') {\n        // handle the infamous raw deflate response from old servers\n        // a hack for old IIS and Apache servers\n        const raw = res.pipe(new PassThrough());\n        raw.once('data', chunk => {\n          // see http://stackoverflow.com/questions/37519828\n          if ((chunk[0] & 0x0F) === 0x08) {\n            body = body.pipe(zlib.createInflate(zlibOptions));\n          } else {\n            body = body.pipe(zlib.createInflateRaw(zlibOptions));\n          }\n\n          resolve(new Response(body, responseOptions));\n        });\n        return;\n      } // otherwise, use response as-is\n\n\n      resolve(new Response(body, responseOptions));\n    });\n    writeToStream(req, request);\n  });\n}\n\n;\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\n\nfetch.isRedirect = code => code === 301 || code === 302 || code === 303 || code === 307 || code === 308; // expose Promise\n\n\nfetch.Promise = global.Promise;\nexports.Headers = Headers;\nexports.Request = Request;\nexports.Response = Response;\nexports.FetchError = FetchError;","map":{"version":3,"sources":["/Users/moonbox/Documents/capstone/pantrypal/node_modules/npm/node_modules/node-fetch-npm/src/index.js"],"names":["url","require","http","https","zlib","PassThrough","Body","writeToStream","Response","Headers","Request","getNodeRequestOptions","FetchError","isURL","exports","module","fetch","uri","opts","Promise","Error","resolve","reject","request","options","send","protocol","headers","host","req","reqTimeout","timeout","once","socket","setTimeout","abort","on","err","clearTimeout","message","res","isRedirect","statusCode","redirect","counter","follow","location","resolvedUrl","redirectURL","test","parse","hostname","delete","method","body","name","Object","keys","Array","isArray","val","append","has","set","get","pipe","responseOptions","status","statusText","statusMessage","size","codings","compress","zlibOptions","flush","Z_SYNC_FLUSH","finishFlush","createGunzip","raw","chunk","createInflate","createInflateRaw","code","global"],"mappings":"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","sourcesContent":["'use strict'\n\n/**\n * index.js\n *\n * a request API compatible with window.fetch\n */\n\nconst url = require('url')\nconst http = require('http')\nconst https = require('https')\nconst zlib = require('zlib')\nconst PassThrough = require('stream').PassThrough\n\nconst Body = require('./body.js')\nconst writeToStream = Body.writeToStream\nconst Response = require('./response')\nconst Headers = require('./headers')\nconst Request = require('./request')\nconst getNodeRequestOptions = Request.getNodeRequestOptions\nconst FetchError = require('./fetch-error')\nconst isURL = /^https?:/\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nexports = module.exports = fetch\nfunction fetch (uri, opts) {\n  // allow custom promise\n  if (!fetch.Promise) {\n    throw new Error('native promise missing, set fetch.Promise to your favorite alternative')\n  }\n\n  Body.Promise = fetch.Promise\n\n  // wrap http.request into fetch\n  return new fetch.Promise((resolve, reject) => {\n    // build request object\n    const request = new Request(uri, opts)\n    const options = getNodeRequestOptions(request)\n\n    const send = (options.protocol === 'https:' ? https : http).request\n\n    // http.request only support string as host header, this hack make custom host header possible\n    if (options.headers.host) {\n      options.headers.host = options.headers.host[0]\n    }\n\n    // send request\n    const req = send(options)\n    let reqTimeout\n\n    if (request.timeout) {\n      req.once('socket', socket => {\n        reqTimeout = setTimeout(() => {\n          req.abort()\n          reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'))\n        }, request.timeout)\n      })\n    }\n\n    req.on('error', err => {\n      clearTimeout(reqTimeout)\n      reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err))\n    })\n\n    req.on('response', res => {\n      clearTimeout(reqTimeout)\n\n      // handle redirect\n      if (fetch.isRedirect(res.statusCode) && request.redirect !== 'manual') {\n        if (request.redirect === 'error') {\n          reject(new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect'))\n          return\n        }\n\n        if (request.counter >= request.follow) {\n          reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'))\n          return\n        }\n\n        if (!res.headers.location) {\n          reject(new FetchError(`redirect location header missing at: ${request.url}`, 'invalid-redirect'))\n          return\n        }\n        // Remove authorization if changing hostnames (but not if just\n        // changing ports or protocols).  This matches the behavior of request:\n        // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n        const resolvedUrl = url.resolve(request.url, res.headers.location)\n        let redirectURL = ''\n        if (!isURL.test(res.headers.location)) {\n          redirectURL = url.parse(resolvedUrl)\n        } else {\n          redirectURL = url.parse(res.headers.location)\n        }\n        if (url.parse(request.url).hostname !== redirectURL.hostname) {\n          request.headers.delete('authorization')\n        }\n\n        // per fetch spec, for POST request with 301/302 response, or any request with 303 response, use GET when following redirect\n        if (res.statusCode === 303 ||\n          ((res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST')) {\n          request.method = 'GET'\n          request.body = null\n          request.headers.delete('content-length')\n        }\n\n        request.counter++\n\n        resolve(fetch(resolvedUrl, request))\n        return\n      }\n\n      // normalize location header for manual redirect mode\n      const headers = new Headers()\n      for (const name of Object.keys(res.headers)) {\n        if (Array.isArray(res.headers[name])) {\n          for (const val of res.headers[name]) {\n            headers.append(name, val)\n          }\n        } else {\n          headers.append(name, res.headers[name])\n        }\n      }\n      if (request.redirect === 'manual' && headers.has('location')) {\n        headers.set('location', url.resolve(request.url, headers.get('location')))\n      }\n\n      // prepare response\n      let body = res.pipe(new PassThrough())\n      const responseOptions = {\n        url: request.url,\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: headers,\n        size: request.size,\n        timeout: request.timeout\n      }\n\n      // HTTP-network fetch step 16.1.2\n      const codings = headers.get('Content-Encoding')\n\n      // HTTP-network fetch step 16.1.3: handle content codings\n\n      // in following scenarios we ignore compression support\n      // 1. compression support is disabled\n      // 2. HEAD request\n      // 3. no Content-Encoding header\n      // 4. no content response (204)\n      // 5. content not modified response (304)\n      if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n        resolve(new Response(body, responseOptions))\n        return\n      }\n\n      // Be less strict when decoding compressed responses, since sometimes\n      // servers send slightly invalid responses that are still accepted\n      // by common browsers.\n      // Always using Z_SYNC_FLUSH is what cURL does.\n      const zlibOptions = {\n        flush: zlib.Z_SYNC_FLUSH,\n        finishFlush: zlib.Z_SYNC_FLUSH\n      }\n\n      // for gzip\n      if (codings === 'gzip' || codings === 'x-gzip') {\n        body = body.pipe(zlib.createGunzip(zlibOptions))\n        resolve(new Response(body, responseOptions))\n        return\n      }\n\n      // for deflate\n      if (codings === 'deflate' || codings === 'x-deflate') {\n        // handle the infamous raw deflate response from old servers\n        // a hack for old IIS and Apache servers\n        const raw = res.pipe(new PassThrough())\n        raw.once('data', chunk => {\n          // see http://stackoverflow.com/questions/37519828\n          if ((chunk[0] & 0x0F) === 0x08) {\n            body = body.pipe(zlib.createInflate(zlibOptions))\n          } else {\n            body = body.pipe(zlib.createInflateRaw(zlibOptions))\n          }\n          resolve(new Response(body, responseOptions))\n        })\n        return\n      }\n\n      // otherwise, use response as-is\n      resolve(new Response(body, responseOptions))\n    })\n\n    writeToStream(req, request)\n  })\n};\n\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = code => code === 301 || code === 302 || code === 303 || code === 307 || code === 308\n\n// expose Promise\nfetch.Promise = global.Promise\nexports.Headers = Headers\nexports.Request = Request\nexports.Response = Response\nexports.FetchError = FetchError\n"]},"metadata":{},"sourceType":"script"}