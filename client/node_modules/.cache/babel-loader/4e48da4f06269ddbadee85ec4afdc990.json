{"ast":null,"code":"'use strict';\n\nlet Cache;\n\nconst url = require('url');\n\nconst CachePolicy = require('http-cache-semantics');\n\nconst fetch = require('node-fetch-npm');\n\nconst pkg = require('./package.json');\n\nconst retry = require('promise-retry');\n\nlet ssri;\n\nconst Stream = require('stream');\n\nconst getAgent = require('./agent');\n\nconst setWarning = require('./warning');\n\nconst isURL = /^https?:/;\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`;\nconst RETRY_ERRORS = ['ECONNRESET', // remote socket closed on us\n'ECONNREFUSED', // remote host refused to open connection\n'EADDRINUSE', // failed to bind to a local port (proxy?)\n'ETIMEDOUT' // someone in the transaction is WAY TOO SLOW\n// Known codes we do NOT retry on:\n// ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n];\nconst RETRY_TYPES = ['request-timeout']; // https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\n\nmodule.exports = cachingFetch;\n\ncachingFetch.defaults = function (_uri, _opts) {\n  const fetch = this;\n\n  if (typeof _uri === 'object') {\n    _opts = _uri;\n    _uri = null;\n  }\n\n  function defaultedFetch(uri, opts) {\n    const finalOpts = Object.assign({}, _opts || {}, opts || {});\n    return fetch(uri || _uri, finalOpts);\n  }\n\n  defaultedFetch.defaults = fetch.defaults;\n  defaultedFetch.delete = fetch.delete;\n  return defaultedFetch;\n};\n\ncachingFetch.delete = cacheDelete;\n\nfunction cacheDelete(uri, opts) {\n  opts = configureOptions(opts);\n\n  if (opts.cacheManager) {\n    const req = new fetch.Request(uri, {\n      method: opts.method,\n      headers: opts.headers\n    });\n    return opts.cacheManager.delete(req, opts);\n  }\n}\n\nfunction initializeCache(opts) {\n  if (typeof opts.cacheManager === 'string') {\n    if (!Cache) {\n      // Default cacache-based cache\n      Cache = require('./cache');\n    }\n\n    opts.cacheManager = new Cache(opts.cacheManager, opts);\n  }\n\n  opts.cache = opts.cache || 'default';\n\n  if (opts.cache === 'default' && isHeaderConditional(opts.headers)) {\n    // If header list contains `If-Modified-Since`, `If-None-Match`,\n    // `If-Unmodified-Since`, `If-Match`, or `If-Range`, fetch will set cache\n    // mode to \"no-store\" if it is \"default\".\n    opts.cache = 'no-store';\n  }\n}\n\nfunction configureOptions(_opts) {\n  const opts = Object.assign({}, _opts || {});\n  opts.method = (opts.method || 'GET').toUpperCase();\n\n  if (opts.retry && typeof opts.retry === 'number') {\n    opts.retry = {\n      retries: opts.retry\n    };\n  }\n\n  if (opts.retry === false) {\n    opts.retry = {\n      retries: 0\n    };\n  }\n\n  if (opts.cacheManager) {\n    initializeCache(opts);\n  }\n\n  return opts;\n}\n\nfunction initializeSsri() {\n  if (!ssri) {\n    ssri = require('ssri');\n  }\n}\n\nfunction cachingFetch(uri, _opts) {\n  const opts = configureOptions(_opts);\n\n  if (opts.integrity) {\n    initializeSsri(); // if verifying integrity, node-fetch must not decompress\n\n    opts.compress = false;\n  }\n\n  const isCachable = (opts.method === 'GET' || opts.method === 'HEAD') && opts.cacheManager && opts.cache !== 'no-store' && opts.cache !== 'reload';\n\n  if (isCachable) {\n    const req = new fetch.Request(uri, {\n      method: opts.method,\n      headers: opts.headers\n    });\n    return opts.cacheManager.match(req, opts).then(res => {\n      if (res) {\n        const warningCode = (res.headers.get('Warning') || '').match(/^\\d+/);\n\n        if (warningCode && +warningCode >= 100 && +warningCode < 200) {\n          // https://tools.ietf.org/html/rfc7234#section-4.3.4\n          //\n          // If a stored response is selected for update, the cache MUST:\n          //\n          // * delete any Warning header fields in the stored response with\n          //   warn-code 1xx (see Section 5.5);\n          //\n          // * retain any Warning header fields in the stored response with\n          //   warn-code 2xx;\n          //\n          res.headers.delete('Warning');\n        }\n\n        if (opts.cache === 'default' && !isStale(req, res)) {\n          return res;\n        }\n\n        if (opts.cache === 'default' || opts.cache === 'no-cache') {\n          return conditionalFetch(req, res, opts);\n        }\n\n        if (opts.cache === 'force-cache' || opts.cache === 'only-if-cached') {\n          //   112 Disconnected operation\n          // SHOULD be included if the cache is intentionally disconnected from\n          // the rest of the network for a period of time.\n          // (https://tools.ietf.org/html/rfc2616#section-14.46)\n          setWarning(res, 112, 'Disconnected operation');\n          return res;\n        }\n      }\n\n      if (!res && opts.cache === 'only-if-cached') {\n        const errorMsg = `request to ${uri} failed: cache mode is 'only-if-cached' but no cached response available.`;\n        const err = new Error(errorMsg);\n        err.code = 'ENOTCACHED';\n        throw err;\n      } // Missing cache entry, or mode is default (if stale), reload, no-store\n\n\n      return remoteFetch(req.url, opts);\n    });\n  }\n\n  return remoteFetch(uri, opts);\n}\n\nfunction iterableToObject(iter) {\n  const obj = {};\n\n  for (let k of iter.keys()) {\n    obj[k] = iter.get(k);\n  }\n\n  return obj;\n}\n\nfunction makePolicy(req, res) {\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: iterableToObject(req.headers)\n  };\n  const _res = {\n    status: res.status,\n    headers: iterableToObject(res.headers)\n  };\n  return new CachePolicy(_req, _res, {\n    shared: false\n  });\n} // https://tools.ietf.org/html/rfc7234#section-4.2\n\n\nfunction isStale(req, res) {\n  if (!res) {\n    return null;\n  }\n\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: iterableToObject(req.headers)\n  };\n  const policy = makePolicy(req, res);\n  const responseTime = res.headers.get('x-local-cache-time') || res.headers.get('date') || 0;\n  policy._responseTime = new Date(responseTime);\n  const bool = !policy.satisfiesWithoutRevalidation(_req);\n  return bool;\n}\n\nfunction mustRevalidate(res) {\n  return (res.headers.get('cache-control') || '').match(/must-revalidate/i);\n}\n\nfunction conditionalFetch(req, cachedRes, opts) {\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: Object.assign({}, opts.headers || {})\n  };\n  const policy = makePolicy(req, cachedRes);\n  opts.headers = policy.revalidationHeaders(_req);\n  return remoteFetch(req.url, opts).then(condRes => {\n    const revalidatedPolicy = policy.revalidatedPolicy(_req, {\n      status: condRes.status,\n      headers: iterableToObject(condRes.headers)\n    });\n\n    if (condRes.status >= 500 && !mustRevalidate(cachedRes)) {\n      //   111 Revalidation failed\n      // MUST be included if a cache returns a stale response because an\n      // attempt to revalidate the response failed, due to an inability to\n      // reach the server.\n      // (https://tools.ietf.org/html/rfc2616#section-14.46)\n      setWarning(cachedRes, 111, 'Revalidation failed');\n      return cachedRes;\n    }\n\n    if (condRes.status === 304) {\n      // 304 Not Modified\n      condRes.body = cachedRes.body;\n      return opts.cacheManager.put(req, condRes, opts).then(newRes => {\n        newRes.headers = new fetch.Headers(revalidatedPolicy.policy.responseHeaders());\n        return newRes;\n      });\n    }\n\n    return condRes;\n  }).then(res => res).catch(err => {\n    if (mustRevalidate(cachedRes)) {\n      throw err;\n    } else {\n      //   111 Revalidation failed\n      // MUST be included if a cache returns a stale response because an\n      // attempt to revalidate the response failed, due to an inability to\n      // reach the server.\n      // (https://tools.ietf.org/html/rfc2616#section-14.46)\n      setWarning(cachedRes, 111, 'Revalidation failed'); //   199 Miscellaneous warning\n      // The warning text MAY include arbitrary information to be presented to\n      // a human user, or logged. A system receiving this warning MUST NOT take\n      // any automated action, besides presenting the warning to the user.\n      // (https://tools.ietf.org/html/rfc2616#section-14.46)\n\n      setWarning(cachedRes, 199, `Miscellaneous Warning ${err.code}: ${err.message}`);\n      return cachedRes;\n    }\n  });\n}\n\nfunction remoteFetchHandleIntegrity(res, integrity) {\n  const oldBod = res.body;\n  const newBod = ssri.integrityStream({\n    integrity\n  });\n  oldBod.pipe(newBod);\n  res.body = newBod;\n  oldBod.once('error', err => {\n    newBod.emit('error', err);\n  });\n  newBod.once('error', err => {\n    oldBod.emit('error', err);\n  });\n}\n\nfunction remoteFetch(uri, opts) {\n  const agent = getAgent(uri, opts);\n  const headers = Object.assign({\n    'connection': agent ? 'keep-alive' : 'close',\n    'user-agent': USER_AGENT\n  }, opts.headers || {});\n  const reqOpts = {\n    agent,\n    body: opts.body,\n    compress: opts.compress,\n    follow: opts.follow,\n    headers: new fetch.Headers(headers),\n    method: opts.method,\n    redirect: 'manual',\n    size: opts.size,\n    counter: opts.counter,\n    timeout: opts.timeout\n  };\n  return retry((retryHandler, attemptNum) => {\n    const req = new fetch.Request(uri, reqOpts);\n    return fetch(req).then(res => {\n      res.headers.set('x-fetch-attempts', attemptNum);\n\n      if (opts.integrity) {\n        remoteFetchHandleIntegrity(res, opts.integrity);\n      }\n\n      const isStream = req.body instanceof Stream;\n\n      if (opts.cacheManager) {\n        const isMethodGetHead = req.method === 'GET' || req.method === 'HEAD';\n        const isCachable = opts.cache !== 'no-store' && isMethodGetHead && makePolicy(req, res).storable() && res.status === 200; // No other statuses should be stored!\n\n        if (isCachable) {\n          return opts.cacheManager.put(req, res, opts);\n        }\n\n        if (!isMethodGetHead) {\n          return opts.cacheManager.delete(req).then(() => {\n            if (res.status >= 500 && req.method !== 'POST' && !isStream) {\n              if (typeof opts.onRetry === 'function') {\n                opts.onRetry(res);\n              }\n\n              return retryHandler(res);\n            }\n\n            return res;\n          });\n        }\n      }\n\n      const isRetriable = req.method !== 'POST' && !isStream && (res.status === 408 || // Request Timeout\n      res.status === 420 || // Enhance Your Calm (usually Twitter rate-limit)\n      res.status === 429 || // Too Many Requests (\"standard\" rate-limiting)\n      res.status >= 500 // Assume server errors are momentary hiccups\n      );\n\n      if (isRetriable) {\n        if (typeof opts.onRetry === 'function') {\n          opts.onRetry(res);\n        }\n\n        return retryHandler(res);\n      }\n\n      if (!fetch.isRedirect(res.status) || opts.redirect === 'manual') {\n        return res;\n      } // handle redirects - matches behavior of npm-fetch: https://github.com/bitinn/node-fetch\n\n\n      if (opts.redirect === 'error') {\n        const err = new Error(`redirect mode is set to error: ${uri}`);\n        err.code = 'ENOREDIRECT';\n        throw err;\n      }\n\n      if (!res.headers.get('location')) {\n        const err = new Error(`redirect location header missing at: ${uri}`);\n        err.code = 'EINVALIDREDIRECT';\n        throw err;\n      }\n\n      if (req.counter >= req.follow) {\n        const err = new Error(`maximum redirect reached at: ${uri}`);\n        err.code = 'EMAXREDIRECT';\n        throw err;\n      }\n\n      const resolvedUrl = url.resolve(req.url, res.headers.get('location'));\n      let redirectURL = url.parse(resolvedUrl);\n\n      if (isURL.test(res.headers.get('location'))) {\n        redirectURL = url.parse(res.headers.get('location'));\n      } // Remove authorization if changing hostnames (but not if just\n      // changing ports or protocols).  This matches the behavior of request:\n      // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n\n\n      if (url.parse(req.url).hostname !== redirectURL.hostname) {\n        req.headers.delete('authorization');\n      } // for POST request with 301/302 response, or any request with 303 response,\n      // use GET when following redirect\n\n\n      if (res.status === 303 || (res.status === 301 || res.status === 302) && req.method === 'POST') {\n        opts.method = 'GET';\n        opts.body = null;\n        req.headers.delete('content-length');\n      }\n\n      opts.headers = {};\n      req.headers.forEach((value, name) => {\n        opts.headers[name] = value;\n      });\n      opts.counter = ++req.counter;\n      return cachingFetch(resolvedUrl, opts);\n    }).catch(err => {\n      const code = err.code === 'EPROMISERETRY' ? err.retried.code : err.code;\n      const isRetryError = RETRY_ERRORS.indexOf(code) === -1 && RETRY_TYPES.indexOf(err.type) === -1;\n\n      if (req.method === 'POST' || isRetryError) {\n        throw err;\n      }\n\n      if (typeof opts.onRetry === 'function') {\n        opts.onRetry(err);\n      }\n\n      return retryHandler(err);\n    });\n  }, opts.retry).catch(err => {\n    if (err.status >= 400) {\n      return err;\n    }\n\n    throw err;\n  });\n}\n\nfunction isHeaderConditional(headers) {\n  if (!headers || typeof headers !== 'object') {\n    return false;\n  }\n\n  const modifiers = ['if-modified-since', 'if-none-match', 'if-unmodified-since', 'if-match', 'if-range'];\n  return Object.keys(headers).some(h => modifiers.indexOf(h.toLowerCase()) !== -1);\n}","map":{"version":3,"sources":["/Users/moonbox/Documents/capstone/pantrypal/node_modules/npm/node_modules/make-fetch-happen/index.js"],"names":["Cache","url","require","CachePolicy","fetch","pkg","retry","ssri","Stream","getAgent","setWarning","isURL","USER_AGENT","name","version","RETRY_ERRORS","RETRY_TYPES","module","exports","cachingFetch","defaults","_uri","_opts","defaultedFetch","uri","opts","finalOpts","Object","assign","delete","cacheDelete","configureOptions","cacheManager","req","Request","method","headers","initializeCache","cache","isHeaderConditional","toUpperCase","retries","initializeSsri","integrity","compress","isCachable","match","then","res","warningCode","get","isStale","conditionalFetch","errorMsg","err","Error","code","remoteFetch","iterableToObject","iter","obj","k","keys","makePolicy","_req","_res","status","shared","policy","responseTime","_responseTime","Date","bool","satisfiesWithoutRevalidation","mustRevalidate","cachedRes","revalidationHeaders","condRes","revalidatedPolicy","body","put","newRes","Headers","responseHeaders","catch","message","remoteFetchHandleIntegrity","oldBod","newBod","integrityStream","pipe","once","emit","agent","reqOpts","follow","redirect","size","counter","timeout","retryHandler","attemptNum","set","isStream","isMethodGetHead","storable","onRetry","isRetriable","isRedirect","resolvedUrl","resolve","redirectURL","parse","test","hostname","forEach","value","retried","isRetryError","indexOf","type","modifiers","some","h","toLowerCase"],"mappings":"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","sourcesContent":["'use strict'\n\nlet Cache\nconst url = require('url')\nconst CachePolicy = require('http-cache-semantics')\nconst fetch = require('node-fetch-npm')\nconst pkg = require('./package.json')\nconst retry = require('promise-retry')\nlet ssri\nconst Stream = require('stream')\nconst getAgent = require('./agent')\nconst setWarning = require('./warning')\n\nconst isURL = /^https?:/\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`\n\nconst RETRY_ERRORS = [\n  'ECONNRESET', // remote socket closed on us\n  'ECONNREFUSED', // remote host refused to open connection\n  'EADDRINUSE', // failed to bind to a local port (proxy?)\n  'ETIMEDOUT' // someone in the transaction is WAY TOO SLOW\n  // Known codes we do NOT retry on:\n  // ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n]\n\nconst RETRY_TYPES = [\n  'request-timeout'\n]\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nmodule.exports = cachingFetch\ncachingFetch.defaults = function (_uri, _opts) {\n  const fetch = this\n  if (typeof _uri === 'object') {\n    _opts = _uri\n    _uri = null\n  }\n\n  function defaultedFetch (uri, opts) {\n    const finalOpts = Object.assign({}, _opts || {}, opts || {})\n    return fetch(uri || _uri, finalOpts)\n  }\n\n  defaultedFetch.defaults = fetch.defaults\n  defaultedFetch.delete = fetch.delete\n  return defaultedFetch\n}\n\ncachingFetch.delete = cacheDelete\nfunction cacheDelete (uri, opts) {\n  opts = configureOptions(opts)\n  if (opts.cacheManager) {\n    const req = new fetch.Request(uri, {\n      method: opts.method,\n      headers: opts.headers\n    })\n    return opts.cacheManager.delete(req, opts)\n  }\n}\n\nfunction initializeCache (opts) {\n  if (typeof opts.cacheManager === 'string') {\n    if (!Cache) {\n      // Default cacache-based cache\n      Cache = require('./cache')\n    }\n\n    opts.cacheManager = new Cache(opts.cacheManager, opts)\n  }\n\n  opts.cache = opts.cache || 'default'\n\n  if (opts.cache === 'default' && isHeaderConditional(opts.headers)) {\n    // If header list contains `If-Modified-Since`, `If-None-Match`,\n    // `If-Unmodified-Since`, `If-Match`, or `If-Range`, fetch will set cache\n    // mode to \"no-store\" if it is \"default\".\n    opts.cache = 'no-store'\n  }\n}\n\nfunction configureOptions (_opts) {\n  const opts = Object.assign({}, _opts || {})\n  opts.method = (opts.method || 'GET').toUpperCase()\n\n  if (opts.retry && typeof opts.retry === 'number') {\n    opts.retry = { retries: opts.retry }\n  }\n\n  if (opts.retry === false) {\n    opts.retry = { retries: 0 }\n  }\n\n  if (opts.cacheManager) {\n    initializeCache(opts)\n  }\n\n  return opts\n}\n\nfunction initializeSsri () {\n  if (!ssri) {\n    ssri = require('ssri')\n  }\n}\n\nfunction cachingFetch (uri, _opts) {\n  const opts = configureOptions(_opts)\n\n  if (opts.integrity) {\n    initializeSsri()\n    // if verifying integrity, node-fetch must not decompress\n    opts.compress = false\n  }\n\n  const isCachable = (opts.method === 'GET' || opts.method === 'HEAD') &&\n    opts.cacheManager &&\n    opts.cache !== 'no-store' &&\n    opts.cache !== 'reload'\n\n  if (isCachable) {\n    const req = new fetch.Request(uri, {\n      method: opts.method,\n      headers: opts.headers\n    })\n\n    return opts.cacheManager.match(req, opts).then(res => {\n      if (res) {\n        const warningCode = (res.headers.get('Warning') || '').match(/^\\d+/)\n        if (warningCode && +warningCode >= 100 && +warningCode < 200) {\n          // https://tools.ietf.org/html/rfc7234#section-4.3.4\n          //\n          // If a stored response is selected for update, the cache MUST:\n          //\n          // * delete any Warning header fields in the stored response with\n          //   warn-code 1xx (see Section 5.5);\n          //\n          // * retain any Warning header fields in the stored response with\n          //   warn-code 2xx;\n          //\n          res.headers.delete('Warning')\n        }\n\n        if (opts.cache === 'default' && !isStale(req, res)) {\n          return res\n        }\n\n        if (opts.cache === 'default' || opts.cache === 'no-cache') {\n          return conditionalFetch(req, res, opts)\n        }\n\n        if (opts.cache === 'force-cache' || opts.cache === 'only-if-cached') {\n          //   112 Disconnected operation\n          // SHOULD be included if the cache is intentionally disconnected from\n          // the rest of the network for a period of time.\n          // (https://tools.ietf.org/html/rfc2616#section-14.46)\n          setWarning(res, 112, 'Disconnected operation')\n          return res\n        }\n      }\n\n      if (!res && opts.cache === 'only-if-cached') {\n        const errorMsg = `request to ${\n          uri\n        } failed: cache mode is 'only-if-cached' but no cached response available.`\n\n        const err = new Error(errorMsg)\n        err.code = 'ENOTCACHED'\n        throw err\n      }\n\n      // Missing cache entry, or mode is default (if stale), reload, no-store\n      return remoteFetch(req.url, opts)\n    })\n  }\n\n  return remoteFetch(uri, opts)\n}\n\nfunction iterableToObject (iter) {\n  const obj = {}\n  for (let k of iter.keys()) {\n    obj[k] = iter.get(k)\n  }\n  return obj\n}\n\nfunction makePolicy (req, res) {\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: iterableToObject(req.headers)\n  }\n  const _res = {\n    status: res.status,\n    headers: iterableToObject(res.headers)\n  }\n\n  return new CachePolicy(_req, _res, { shared: false })\n}\n\n// https://tools.ietf.org/html/rfc7234#section-4.2\nfunction isStale (req, res) {\n  if (!res) {\n    return null\n  }\n\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: iterableToObject(req.headers)\n  }\n\n  const policy = makePolicy(req, res)\n\n  const responseTime = res.headers.get('x-local-cache-time') ||\n    res.headers.get('date') ||\n    0\n\n  policy._responseTime = new Date(responseTime)\n\n  const bool = !policy.satisfiesWithoutRevalidation(_req)\n  return bool\n}\n\nfunction mustRevalidate (res) {\n  return (res.headers.get('cache-control') || '').match(/must-revalidate/i)\n}\n\nfunction conditionalFetch (req, cachedRes, opts) {\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: Object.assign({}, opts.headers || {})\n  }\n\n  const policy = makePolicy(req, cachedRes)\n  opts.headers = policy.revalidationHeaders(_req)\n\n  return remoteFetch(req.url, opts)\n    .then(condRes => {\n      const revalidatedPolicy = policy.revalidatedPolicy(_req, {\n        status: condRes.status,\n        headers: iterableToObject(condRes.headers)\n      })\n\n      if (condRes.status >= 500 && !mustRevalidate(cachedRes)) {\n        //   111 Revalidation failed\n        // MUST be included if a cache returns a stale response because an\n        // attempt to revalidate the response failed, due to an inability to\n        // reach the server.\n        // (https://tools.ietf.org/html/rfc2616#section-14.46)\n        setWarning(cachedRes, 111, 'Revalidation failed')\n        return cachedRes\n      }\n\n      if (condRes.status === 304) { // 304 Not Modified\n        condRes.body = cachedRes.body\n        return opts.cacheManager.put(req, condRes, opts)\n          .then(newRes => {\n            newRes.headers = new fetch.Headers(revalidatedPolicy.policy.responseHeaders())\n            return newRes\n          })\n      }\n\n      return condRes\n    })\n    .then(res => res)\n    .catch(err => {\n      if (mustRevalidate(cachedRes)) {\n        throw err\n      } else {\n        //   111 Revalidation failed\n        // MUST be included if a cache returns a stale response because an\n        // attempt to revalidate the response failed, due to an inability to\n        // reach the server.\n        // (https://tools.ietf.org/html/rfc2616#section-14.46)\n        setWarning(cachedRes, 111, 'Revalidation failed')\n        //   199 Miscellaneous warning\n        // The warning text MAY include arbitrary information to be presented to\n        // a human user, or logged. A system receiving this warning MUST NOT take\n        // any automated action, besides presenting the warning to the user.\n        // (https://tools.ietf.org/html/rfc2616#section-14.46)\n        setWarning(\n          cachedRes,\n          199,\n          `Miscellaneous Warning ${err.code}: ${err.message}`\n        )\n\n        return cachedRes\n      }\n    })\n}\n\nfunction remoteFetchHandleIntegrity (res, integrity) {\n  const oldBod = res.body\n  const newBod = ssri.integrityStream({\n    integrity\n  })\n  oldBod.pipe(newBod)\n  res.body = newBod\n  oldBod.once('error', err => {\n    newBod.emit('error', err)\n  })\n  newBod.once('error', err => {\n    oldBod.emit('error', err)\n  })\n}\n\nfunction remoteFetch (uri, opts) {\n  const agent = getAgent(uri, opts)\n  const headers = Object.assign({\n    'connection': agent ? 'keep-alive' : 'close',\n    'user-agent': USER_AGENT\n  }, opts.headers || {})\n\n  const reqOpts = {\n    agent,\n    body: opts.body,\n    compress: opts.compress,\n    follow: opts.follow,\n    headers: new fetch.Headers(headers),\n    method: opts.method,\n    redirect: 'manual',\n    size: opts.size,\n    counter: opts.counter,\n    timeout: opts.timeout\n  }\n\n  return retry(\n    (retryHandler, attemptNum) => {\n      const req = new fetch.Request(uri, reqOpts)\n      return fetch(req)\n        .then(res => {\n          res.headers.set('x-fetch-attempts', attemptNum)\n\n          if (opts.integrity) {\n            remoteFetchHandleIntegrity(res, opts.integrity)\n          }\n\n          const isStream = req.body instanceof Stream\n\n          if (opts.cacheManager) {\n            const isMethodGetHead = req.method === 'GET' ||\n              req.method === 'HEAD'\n\n            const isCachable = opts.cache !== 'no-store' &&\n              isMethodGetHead &&\n              makePolicy(req, res).storable() &&\n              res.status === 200 // No other statuses should be stored!\n\n            if (isCachable) {\n              return opts.cacheManager.put(req, res, opts)\n            }\n\n            if (!isMethodGetHead) {\n              return opts.cacheManager.delete(req).then(() => {\n                if (res.status >= 500 && req.method !== 'POST' && !isStream) {\n                  if (typeof opts.onRetry === 'function') {\n                    opts.onRetry(res)\n                  }\n\n                  return retryHandler(res)\n                }\n\n                return res\n              })\n            }\n          }\n\n          const isRetriable = req.method !== 'POST' &&\n            !isStream && (\n              res.status === 408 || // Request Timeout\n              res.status === 420 || // Enhance Your Calm (usually Twitter rate-limit)\n              res.status === 429 || // Too Many Requests (\"standard\" rate-limiting)\n              res.status >= 500 // Assume server errors are momentary hiccups\n            )\n\n          if (isRetriable) {\n            if (typeof opts.onRetry === 'function') {\n              opts.onRetry(res)\n            }\n\n            return retryHandler(res)\n          }\n\n          if (!fetch.isRedirect(res.status) || opts.redirect === 'manual') {\n            return res\n          }\n\n          // handle redirects - matches behavior of npm-fetch: https://github.com/bitinn/node-fetch\n          if (opts.redirect === 'error') {\n            const err = new Error(`redirect mode is set to error: ${uri}`)\n            err.code = 'ENOREDIRECT'\n            throw err\n          }\n\n          if (!res.headers.get('location')) {\n            const err = new Error(`redirect location header missing at: ${uri}`)\n            err.code = 'EINVALIDREDIRECT'\n            throw err\n          }\n\n          if (req.counter >= req.follow) {\n            const err = new Error(`maximum redirect reached at: ${uri}`)\n            err.code = 'EMAXREDIRECT'\n            throw err\n          }\n\n          const resolvedUrl = url.resolve(req.url, res.headers.get('location'))\n          let redirectURL = url.parse(resolvedUrl)\n\n          if (isURL.test(res.headers.get('location'))) {\n            redirectURL = url.parse(res.headers.get('location'))\n          }\n\n          // Remove authorization if changing hostnames (but not if just\n          // changing ports or protocols).  This matches the behavior of request:\n          // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n          if (url.parse(req.url).hostname !== redirectURL.hostname) {\n            req.headers.delete('authorization')\n          }\n\n          // for POST request with 301/302 response, or any request with 303 response,\n          // use GET when following redirect\n          if (res.status === 303 ||\n            ((res.status === 301 || res.status === 302) && req.method === 'POST')) {\n            opts.method = 'GET'\n            opts.body = null\n            req.headers.delete('content-length')\n          }\n\n          opts.headers = {}\n          req.headers.forEach((value, name) => {\n            opts.headers[name] = value\n          })\n\n          opts.counter = ++req.counter\n          return cachingFetch(resolvedUrl, opts)\n        })\n        .catch(err => {\n          const code = err.code === 'EPROMISERETRY' ? err.retried.code : err.code\n\n          const isRetryError = RETRY_ERRORS.indexOf(code) === -1 &&\n            RETRY_TYPES.indexOf(err.type) === -1\n\n          if (req.method === 'POST' || isRetryError) {\n            throw err\n          }\n\n          if (typeof opts.onRetry === 'function') {\n            opts.onRetry(err)\n          }\n\n          return retryHandler(err)\n        })\n    },\n    opts.retry\n  ).catch(err => {\n    if (err.status >= 400) {\n      return err\n    }\n\n    throw err\n  })\n}\n\nfunction isHeaderConditional (headers) {\n  if (!headers || typeof headers !== 'object') {\n    return false\n  }\n\n  const modifiers = [\n    'if-modified-since',\n    'if-none-match',\n    'if-unmodified-since',\n    'if-match',\n    'if-range'\n  ]\n\n  return Object.keys(headers)\n    .some(h => modifiers.indexOf(h.toLowerCase()) !== -1)\n}\n"]},"metadata":{},"sourceType":"script"}