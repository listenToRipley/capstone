{"ast":null,"code":"'use strict';\n\nvar _errors = require('../errors');\n\nvar _JwksClient = require('../JwksClient');\n\nvar handleSigningKeyError = function handleSigningKeyError(err, cb) {\n  // If we didn't find a match, can't provide a key.\n  if (err && err.name === 'SigningKeyNotFoundError') {\n    return cb(err, null, null);\n  } // If an error occured like rate limiting or HTTP issue, we'll bubble up the error.\n\n\n  if (err) {\n    return cb(err, null, null);\n  }\n};\n/**\n * Call hapiJwt2Key as a Promise\n * @param {object} options \n * @returns {Promise}\n */\n\n\nmodule.exports.hapiJwt2KeyAsync = function (options) {\n  var secretProvider = module.exports.hapiJwt2Key(options);\n  return function (decoded) {\n    return new Promise(function (resolve, reject) {\n      var cb = function cb(err, key) {\n        !key || err ? reject(err) : resolve({\n          key: key\n        });\n      };\n\n      secretProvider(decoded, cb);\n    });\n  };\n};\n\nmodule.exports.hapiJwt2Key = function (options) {\n  if (options === null || options === undefined) {\n    throw new _errors.ArgumentError('An options object must be provided when initializing hapiJwt2Key');\n  }\n\n  var client = new _JwksClient.JwksClient(options);\n  var onError = options.handleSigningKeyError || handleSigningKeyError;\n  return function secretProvider(decoded, cb) {\n    // We cannot find a signing certificate if there is no header (no kid).\n    if (!decoded || !decoded.header) {\n      return cb(new Error('Cannot find a signing certificate if there is no header'), null, null);\n    } // Only RS256 is supported.\n\n\n    if (decoded.header.alg !== 'RS256') {\n      return cb(new Error('Unsupported algorithm ' + decoded.header.alg + ' supplied. node-jwks-rsa supports only RS256'), null, null);\n    }\n\n    client.getSigningKey(decoded.header.kid, function (err, key) {\n      if (err) {\n        return onError(err, function (newError) {\n          return cb(newError, null, null);\n        });\n      } // Provide the key.\n\n\n      return cb(null, key.publicKey || key.rsaPublicKey, key);\n    });\n  };\n};","map":{"version":3,"sources":["/Users/moonbox/Documents/capstone/pantrypal/node_modules/jwks-rsa/lib/integrations/hapi.js"],"names":["_errors","require","_JwksClient","handleSigningKeyError","err","cb","name","module","exports","hapiJwt2KeyAsync","options","secretProvider","hapiJwt2Key","decoded","Promise","resolve","reject","key","undefined","ArgumentError","client","JwksClient","onError","header","Error","alg","getSigningKey","kid","newError","publicKey","rsaPublicKey"],"mappings":"AAAA;;AAEA,IAAIA,OAAO,GAAGC,OAAO,CAAC,WAAD,CAArB;;AAEA,IAAIC,WAAW,GAAGD,OAAO,CAAC,eAAD,CAAzB;;AAEA,IAAIE,qBAAqB,GAAG,SAASA,qBAAT,CAA+BC,GAA/B,EAAoCC,EAApC,EAAwC;AAClE;AACA,MAAID,GAAG,IAAIA,GAAG,CAACE,IAAJ,KAAa,yBAAxB,EAAmD;AACjD,WAAOD,EAAE,CAACD,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAT;AACD,GAJiE,CAMlE;;;AACA,MAAIA,GAAJ,EAAS;AACP,WAAOC,EAAE,CAACD,GAAD,EAAM,IAAN,EAAY,IAAZ,CAAT;AACD;AACF,CAVD;AAYA;AACA;AACA;AACA;AACA;;;AACAG,MAAM,CAACC,OAAP,CAAeC,gBAAf,GAAkC,UAAUC,OAAV,EAAmB;AACnD,MAAIC,cAAc,GAAGJ,MAAM,CAACC,OAAP,CAAeI,WAAf,CAA2BF,OAA3B,CAArB;AACA,SAAO,UAAUG,OAAV,EAAmB;AACxB,WAAO,IAAIC,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5C,UAAIX,EAAE,GAAG,SAASA,EAAT,CAAYD,GAAZ,EAAiBa,GAAjB,EAAsB;AAC7B,SAACA,GAAD,IAAQb,GAAR,GAAcY,MAAM,CAACZ,GAAD,CAApB,GAA4BW,OAAO,CAAC;AAAEE,UAAAA,GAAG,EAAEA;AAAP,SAAD,CAAnC;AACD,OAFD;;AAGAN,MAAAA,cAAc,CAACE,OAAD,EAAUR,EAAV,CAAd;AACD,KALM,CAAP;AAMD,GAPD;AAQD,CAVD;;AAYAE,MAAM,CAACC,OAAP,CAAeI,WAAf,GAA6B,UAAUF,OAAV,EAAmB;AAC9C,MAAIA,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAKQ,SAApC,EAA+C;AAC7C,UAAM,IAAIlB,OAAO,CAACmB,aAAZ,CAA0B,kEAA1B,CAAN;AACD;;AAED,MAAIC,MAAM,GAAG,IAAIlB,WAAW,CAACmB,UAAhB,CAA2BX,OAA3B,CAAb;AACA,MAAIY,OAAO,GAAGZ,OAAO,CAACP,qBAAR,IAAiCA,qBAA/C;AAEA,SAAO,SAASQ,cAAT,CAAwBE,OAAxB,EAAiCR,EAAjC,EAAqC;AAC1C;AACA,QAAI,CAACQ,OAAD,IAAY,CAACA,OAAO,CAACU,MAAzB,EAAiC;AAC/B,aAAOlB,EAAE,CAAC,IAAImB,KAAJ,CAAU,yDAAV,CAAD,EAAuE,IAAvE,EAA6E,IAA7E,CAAT;AACD,KAJyC,CAM1C;;;AACA,QAAIX,OAAO,CAACU,MAAR,CAAeE,GAAf,KAAuB,OAA3B,EAAoC;AAClC,aAAOpB,EAAE,CAAC,IAAImB,KAAJ,CAAU,2BAA2BX,OAAO,CAACU,MAAR,CAAeE,GAA1C,GAAgD,8CAA1D,CAAD,EAA4G,IAA5G,EAAkH,IAAlH,CAAT;AACD;;AAEDL,IAAAA,MAAM,CAACM,aAAP,CAAqBb,OAAO,CAACU,MAAR,CAAeI,GAApC,EAAyC,UAAUvB,GAAV,EAAea,GAAf,EAAoB;AAC3D,UAAIb,GAAJ,EAAS;AACP,eAAOkB,OAAO,CAAClB,GAAD,EAAM,UAAUwB,QAAV,EAAoB;AACtC,iBAAOvB,EAAE,CAACuB,QAAD,EAAW,IAAX,EAAiB,IAAjB,CAAT;AACD,SAFa,CAAd;AAGD,OAL0D,CAO3D;;;AACA,aAAOvB,EAAE,CAAC,IAAD,EAAOY,GAAG,CAACY,SAAJ,IAAiBZ,GAAG,CAACa,YAA5B,EAA0Cb,GAA1C,CAAT;AACD,KATD;AAUD,GArBD;AAsBD,CA9BD","sourcesContent":["'use strict';\n\nvar _errors = require('../errors');\n\nvar _JwksClient = require('../JwksClient');\n\nvar handleSigningKeyError = function handleSigningKeyError(err, cb) {\n  // If we didn't find a match, can't provide a key.\n  if (err && err.name === 'SigningKeyNotFoundError') {\n    return cb(err, null, null);\n  }\n\n  // If an error occured like rate limiting or HTTP issue, we'll bubble up the error.\n  if (err) {\n    return cb(err, null, null);\n  }\n};\n\n/**\n * Call hapiJwt2Key as a Promise\n * @param {object} options \n * @returns {Promise}\n */\nmodule.exports.hapiJwt2KeyAsync = function (options) {\n  var secretProvider = module.exports.hapiJwt2Key(options);\n  return function (decoded) {\n    return new Promise(function (resolve, reject) {\n      var cb = function cb(err, key) {\n        !key || err ? reject(err) : resolve({ key: key });\n      };\n      secretProvider(decoded, cb);\n    });\n  };\n};\n\nmodule.exports.hapiJwt2Key = function (options) {\n  if (options === null || options === undefined) {\n    throw new _errors.ArgumentError('An options object must be provided when initializing hapiJwt2Key');\n  }\n\n  var client = new _JwksClient.JwksClient(options);\n  var onError = options.handleSigningKeyError || handleSigningKeyError;\n\n  return function secretProvider(decoded, cb) {\n    // We cannot find a signing certificate if there is no header (no kid).\n    if (!decoded || !decoded.header) {\n      return cb(new Error('Cannot find a signing certificate if there is no header'), null, null);\n    }\n\n    // Only RS256 is supported.\n    if (decoded.header.alg !== 'RS256') {\n      return cb(new Error('Unsupported algorithm ' + decoded.header.alg + ' supplied. node-jwks-rsa supports only RS256'), null, null);\n    }\n\n    client.getSigningKey(decoded.header.kid, function (err, key) {\n      if (err) {\n        return onError(err, function (newError) {\n          return cb(newError, null, null);\n        });\n      }\n\n      // Provide the key.\n      return cb(null, key.publicKey || key.rsaPublicKey, key);\n    });\n  };\n};"]},"metadata":{},"sourceType":"script"}