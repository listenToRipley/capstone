{"ast":null,"code":"'use strict'; // try to find the most reasonable prefix to use\n\nmodule.exports = findPrefix;\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nfunction findPrefix(dir) {\n  return new Promise((resolve, reject) => {\n    dir = path.resolve(dir); // this is a weird special case where an infinite recurse of\n    // node_modules folders resolves to the level that contains the\n    // very first node_modules folder\n\n    let walkedUp = false;\n\n    while (path.basename(dir) === 'node_modules') {\n      dir = path.dirname(dir);\n      walkedUp = true;\n    }\n\n    if (walkedUp) {\n      resolve(dir);\n    } else {\n      resolve(findPrefix_(dir));\n    }\n  });\n}\n\nfunction findPrefix_(dir, original) {\n  if (!original) original = dir;\n  const parent = path.dirname(dir); // this is a platform independent way of checking if we're in the root\n  // directory\n\n  if (parent === dir) return Promise.resolve(original);\n  return new Promise((resolve, reject) => {\n    fs.readdir(dir, (err, files) => {\n      if (err) {\n        // an error right away is a bad sign.\n        // unless the prefix was simply a non\n        // existent directory.\n        if (err && dir === original && err.code !== 'ENOENT') {\n          reject(err);\n        } else {\n          resolve(original);\n        }\n      } else if (files.indexOf('node_modules') !== -1 || files.indexOf('package.json') !== -1) {\n        resolve(dir);\n      } else {\n        resolve(findPrefix_(parent, original));\n      }\n    });\n  });\n}","map":{"version":3,"sources":["/Users/moonbox/Documents/capstone/pantrypal/client/node_modules/npm/node_modules/find-npm-prefix/find-prefix.js"],"names":["module","exports","findPrefix","fs","require","path","dir","Promise","resolve","reject","walkedUp","basename","dirname","findPrefix_","original","parent","readdir","err","files","code","indexOf"],"mappings":"AAAA,a,CACA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,UAAjB;;AAEA,MAAMC,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AAEA,SAASF,UAAT,CAAqBI,GAArB,EAA0B;AACxB,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCH,IAAAA,GAAG,GAAGD,IAAI,CAACG,OAAL,CAAaF,GAAb,CAAN,CADsC,CAGtC;AACA;AACA;;AACA,QAAII,QAAQ,GAAG,KAAf;;AACA,WAAOL,IAAI,CAACM,QAAL,CAAcL,GAAd,MAAuB,cAA9B,EAA8C;AAC5CA,MAAAA,GAAG,GAAGD,IAAI,CAACO,OAAL,CAAaN,GAAb,CAAN;AACAI,MAAAA,QAAQ,GAAG,IAAX;AACD;;AACD,QAAIA,QAAJ,EAAc;AACZF,MAAAA,OAAO,CAACF,GAAD,CAAP;AACD,KAFD,MAEO;AACLE,MAAAA,OAAO,CAACK,WAAW,CAACP,GAAD,CAAZ,CAAP;AACD;AACF,GAhBM,CAAP;AAiBD;;AAED,SAASO,WAAT,CAAsBP,GAAtB,EAA2BQ,QAA3B,EAAqC;AACnC,MAAI,CAACA,QAAL,EAAeA,QAAQ,GAAGR,GAAX;AAEf,QAAMS,MAAM,GAAGV,IAAI,CAACO,OAAL,CAAaN,GAAb,CAAf,CAHmC,CAInC;AACA;;AACA,MAAIS,MAAM,KAAKT,GAAf,EAAoB,OAAOC,OAAO,CAACC,OAAR,CAAgBM,QAAhB,CAAP;AAEpB,SAAO,IAAIP,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCN,IAAAA,EAAE,CAACa,OAAH,CAAWV,GAAX,EAAgB,CAACW,GAAD,EAAMC,KAAN,KAAgB;AAC9B,UAAID,GAAJ,EAAS;AACP;AACA;AACA;AACA,YAAIA,GAAG,IAAIX,GAAG,KAAKQ,QAAf,IAA2BG,GAAG,CAACE,IAAJ,KAAa,QAA5C,EAAsD;AACpDV,UAAAA,MAAM,CAACQ,GAAD,CAAN;AACD,SAFD,MAEO;AACLT,UAAAA,OAAO,CAACM,QAAD,CAAP;AACD;AACF,OATD,MASO,IAAII,KAAK,CAACE,OAAN,CAAc,cAAd,MAAkC,CAAC,CAAnC,IACAF,KAAK,CAACE,OAAN,CAAc,cAAd,MAAkC,CAAC,CADvC,EAC0C;AAC/CZ,QAAAA,OAAO,CAACF,GAAD,CAAP;AACD,OAHM,MAGA;AACLE,QAAAA,OAAO,CAACK,WAAW,CAACE,MAAD,EAASD,QAAT,CAAZ,CAAP;AACD;AACF,KAhBD;AAiBD,GAlBM,CAAP;AAmBD","sourcesContent":["'use strict'\n// try to find the most reasonable prefix to use\n\nmodule.exports = findPrefix\n\nconst fs = require('fs')\nconst path = require('path')\n\nfunction findPrefix (dir) {\n  return new Promise((resolve, reject) => {\n    dir = path.resolve(dir)\n\n    // this is a weird special case where an infinite recurse of\n    // node_modules folders resolves to the level that contains the\n    // very first node_modules folder\n    let walkedUp = false\n    while (path.basename(dir) === 'node_modules') {\n      dir = path.dirname(dir)\n      walkedUp = true\n    }\n    if (walkedUp) {\n      resolve(dir)\n    } else {\n      resolve(findPrefix_(dir))\n    }\n  })\n}\n\nfunction findPrefix_ (dir, original) {\n  if (!original) original = dir\n\n  const parent = path.dirname(dir)\n  // this is a platform independent way of checking if we're in the root\n  // directory\n  if (parent === dir) return Promise.resolve(original)\n\n  return new Promise((resolve, reject) => {\n    fs.readdir(dir, (err, files) => {\n      if (err) {\n        // an error right away is a bad sign.\n        // unless the prefix was simply a non\n        // existent directory.\n        if (err && dir === original && err.code !== 'ENOENT') {\n          reject(err)\n        } else {\n          resolve(original)\n        }\n      } else if (files.indexOf('node_modules') !== -1 ||\n                 files.indexOf('package.json') !== -1) {\n        resolve(dir)\n      } else {\n        resolve(findPrefix_(parent, original))\n      }\n    })\n  })\n}\n"]},"metadata":{},"sourceType":"script"}