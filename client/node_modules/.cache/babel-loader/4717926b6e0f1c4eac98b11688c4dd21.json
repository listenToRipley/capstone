{"ast":null,"code":"// XXX use infer-owner or gentle-fs.mkdir here\nconst npm = require('../npm.js');\n\nconst path = require('path');\n\nconst chownr = require('chownr');\n\nconst writeFileAtomic = require('write-file-atomic');\n\nconst mkdirp = require('mkdirp');\n\nconst fs = require('graceful-fs');\n\nlet cache = null;\nlet cacheUid = null;\nlet cacheGid = null;\nlet needChown = typeof process.getuid === 'function';\n\nconst getCacheOwner = () => {\n  let st;\n\n  try {\n    st = fs.lstatSync(cache);\n  } catch (er) {\n    if (er.code !== 'ENOENT') {\n      throw er;\n    }\n\n    st = fs.lstatSync(path.dirname(cache));\n  }\n\n  cacheUid = st.uid;\n  cacheGid = st.gid;\n  needChown = st.uid !== process.getuid() || st.gid !== process.getgid();\n};\n\nconst writeOrAppend = (method, file, data) => {\n  if (!cache) {\n    cache = npm.config.get('cache');\n  } // redundant if already absolute, but prevents non-absolute files\n  // from being written as if they're part of the cache.\n\n\n  file = path.resolve(cache, file);\n\n  if (cacheUid === null && needChown) {\n    getCacheOwner();\n  }\n\n  const dir = path.dirname(file);\n  const firstMade = mkdirp.sync(dir);\n\n  if (!needChown) {\n    return method(file, data);\n  }\n\n  let methodThrew = true;\n\n  try {\n    method(file, data);\n    methodThrew = false;\n  } finally {\n    // always try to leave it in the right ownership state, even on failure\n    // let the method error fail it instead of the chownr error, though\n    if (!methodThrew) {\n      chownr.sync(firstMade || file, cacheUid, cacheGid);\n    } else {\n      try {\n        chownr.sync(firstMade || file, cacheUid, cacheGid);\n      } catch (_) {}\n    }\n  }\n};\n\nexports.append = (file, data) => writeOrAppend(fs.appendFileSync, file, data);\n\nexports.write = (file, data) => writeOrAppend(writeFileAtomic.sync, file, data);","map":{"version":3,"sources":["/Users/moonbox/Documents/capstone/pantrypal/client/node_modules/npm/lib/utils/cache-file.js"],"names":["npm","require","path","chownr","writeFileAtomic","mkdirp","fs","cache","cacheUid","cacheGid","needChown","process","getuid","getCacheOwner","st","lstatSync","er","code","dirname","uid","gid","getgid","writeOrAppend","method","file","data","config","get","resolve","dir","firstMade","sync","methodThrew","_","exports","append","appendFileSync","write"],"mappings":"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","sourcesContent":["// XXX use infer-owner or gentle-fs.mkdir here\nconst npm = require('../npm.js')\nconst path = require('path')\nconst chownr = require('chownr')\nconst writeFileAtomic = require('write-file-atomic')\nconst mkdirp = require('mkdirp')\nconst fs = require('graceful-fs')\n\nlet cache = null\nlet cacheUid = null\nlet cacheGid = null\nlet needChown = typeof process.getuid === 'function'\n\nconst getCacheOwner = () => {\n  let st\n  try {\n    st = fs.lstatSync(cache)\n  } catch (er) {\n    if (er.code !== 'ENOENT') {\n      throw er\n    }\n    st = fs.lstatSync(path.dirname(cache))\n  }\n\n  cacheUid = st.uid\n  cacheGid = st.gid\n\n  needChown = st.uid !== process.getuid() ||\n    st.gid !== process.getgid()\n}\n\nconst writeOrAppend = (method, file, data) => {\n  if (!cache) {\n    cache = npm.config.get('cache')\n  }\n\n  // redundant if already absolute, but prevents non-absolute files\n  // from being written as if they're part of the cache.\n  file = path.resolve(cache, file)\n\n  if (cacheUid === null && needChown) {\n    getCacheOwner()\n  }\n\n  const dir = path.dirname(file)\n  const firstMade = mkdirp.sync(dir)\n\n  if (!needChown) {\n    return method(file, data)\n  }\n\n  let methodThrew = true\n  try {\n    method(file, data)\n    methodThrew = false\n  } finally {\n    // always try to leave it in the right ownership state, even on failure\n    // let the method error fail it instead of the chownr error, though\n    if (!methodThrew) {\n      chownr.sync(firstMade || file, cacheUid, cacheGid)\n    } else {\n      try {\n        chownr.sync(firstMade || file, cacheUid, cacheGid)\n      } catch (_) {}\n    }\n  }\n}\n\nexports.append = (file, data) => writeOrAppend(fs.appendFileSync, file, data)\nexports.write = (file, data) => writeOrAppend(writeFileAtomic.sync, file, data)\n"]},"metadata":{},"sourceType":"script"}