{"ast":null,"code":"'use strict';\n/**\n * body.js\n *\n * Body interface provides common methods for Request and Response\n */\n\nconst Buffer = require('safe-buffer').Buffer;\n\nconst Blob = require('./blob.js');\n\nconst BUFFER = Blob.BUFFER;\n\nconst convert = require('encoding').convert;\n\nconst parseJson = require('json-parse-better-errors');\n\nconst FetchError = require('./fetch-error.js');\n\nconst Stream = require('stream');\n\nconst PassThrough = Stream.PassThrough;\nconst DISTURBED = Symbol('disturbed');\n/**\n * Body class\n *\n * Cannot use ES6 class because Body must be called with .call().\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\n\nexports = module.exports = Body;\n\nfunction Body(body, opts) {\n  if (!opts) opts = {};\n  const size = opts.size == null ? 0 : opts.size;\n  const timeout = opts.timeout == null ? 0 : opts.timeout;\n\n  if (body == null) {\n    // body is undefined or null\n    body = null;\n  } else if (typeof body === 'string') {// body is string\n  } else if (body instanceof Blob) {// body is blob\n  } else if (Buffer.isBuffer(body)) {// body is buffer\n  } else if (body instanceof Stream) {// body is stream\n  } else {\n    // none of the above\n    // coerce to string\n    body = String(body);\n  }\n\n  this.body = body;\n  this[DISTURBED] = false;\n  this.size = size;\n  this.timeout = timeout;\n}\n\nBody.prototype = {\n  get bodyUsed() {\n    return this[DISTURBED];\n  },\n\n  /**\n   * Decode response as ArrayBuffer\n   *\n   * @return  Promise\n   */\n  arrayBuffer() {\n    return consumeBody.call(this).then(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));\n  },\n\n  /**\n   * Return raw response as Blob\n   *\n   * @return Promise\n   */\n  blob() {\n    let ct = this.headers && this.headers.get('content-type') || '';\n    return consumeBody.call(this).then(buf => Object.assign( // Prevent copying\n    new Blob([], {\n      type: ct.toLowerCase()\n    }), {\n      [BUFFER]: buf\n    }));\n  },\n\n  /**\n   * Decode response as json\n   *\n   * @return  Promise\n   */\n  json() {\n    return consumeBody.call(this).then(buffer => parseJson(buffer.toString()));\n  },\n\n  /**\n   * Decode response as text\n   *\n   * @return  Promise\n   */\n  text() {\n    return consumeBody.call(this).then(buffer => buffer.toString());\n  },\n\n  /**\n   * Decode response as buffer (non-spec api)\n   *\n   * @return  Promise\n   */\n  buffer() {\n    return consumeBody.call(this);\n  },\n\n  /**\n   * Decode response as text, while automatically detecting the encoding and\n   * trying to decode to UTF-8 (non-spec api)\n   *\n   * @return  Promise\n   */\n  textConverted() {\n    return consumeBody.call(this).then(buffer => convertBody(buffer, this.headers));\n  }\n\n};\n\nBody.mixIn = function (proto) {\n  for (const name of Object.getOwnPropertyNames(Body.prototype)) {\n    // istanbul ignore else: future proof\n    if (!(name in proto)) {\n      const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n      Object.defineProperty(proto, name, desc);\n    }\n  }\n};\n/**\n * Decode buffers into utf-8 string\n *\n * @return  Promise\n */\n\n\nfunction consumeBody(body) {\n  if (this[DISTURBED]) {\n    return Body.Promise.reject(new Error(`body used already for: ${this.url}`));\n  }\n\n  this[DISTURBED] = true; // body is null\n\n  if (this.body === null) {\n    return Body.Promise.resolve(Buffer.alloc(0));\n  } // body is string\n\n\n  if (typeof this.body === 'string') {\n    return Body.Promise.resolve(Buffer.from(this.body));\n  } // body is blob\n\n\n  if (this.body instanceof Blob) {\n    return Body.Promise.resolve(this.body[BUFFER]);\n  } // body is buffer\n\n\n  if (Buffer.isBuffer(this.body)) {\n    return Body.Promise.resolve(this.body);\n  } // istanbul ignore if: should never happen\n\n\n  if (!(this.body instanceof Stream)) {\n    return Body.Promise.resolve(Buffer.alloc(0));\n  } // body is stream\n  // get ready to actually consume the body\n\n\n  let accum = [];\n  let accumBytes = 0;\n  let abort = false;\n  return new Body.Promise((resolve, reject) => {\n    let resTimeout; // allow timeout on slow response body\n\n    if (this.timeout) {\n      resTimeout = setTimeout(() => {\n        abort = true;\n        reject(new FetchError(`Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`, 'body-timeout'));\n      }, this.timeout);\n    } // handle stream error, such as incorrect content-encoding\n\n\n    this.body.on('error', err => {\n      reject(new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, 'system', err));\n    });\n    this.body.on('data', chunk => {\n      if (abort || chunk === null) {\n        return;\n      }\n\n      if (this.size && accumBytes + chunk.length > this.size) {\n        abort = true;\n        reject(new FetchError(`content size at ${this.url} over limit: ${this.size}`, 'max-size'));\n        return;\n      }\n\n      accumBytes += chunk.length;\n      accum.push(chunk);\n    });\n    this.body.on('end', () => {\n      if (abort) {\n        return;\n      }\n\n      clearTimeout(resTimeout);\n      resolve(Buffer.concat(accum));\n    });\n  });\n}\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\n\n\nfunction convertBody(buffer, headers) {\n  const ct = headers.get('content-type');\n  let charset = 'utf-8';\n  let res, str; // header\n\n  if (ct) {\n    res = /charset=([^;]*)/i.exec(ct);\n  } // no charset in content type, peek at response body for at most 1024 bytes\n\n\n  str = buffer.slice(0, 1024).toString(); // html5\n\n  if (!res && str) {\n    res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n  } // html4\n\n\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\n    if (res) {\n      res = /charset=(.*)/i.exec(res.pop());\n    }\n  } // xml\n\n\n  if (!res && str) {\n    res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n  } // found charset\n\n\n  if (res) {\n    charset = res.pop(); // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n\n    if (charset === 'gb2312' || charset === 'gbk') {\n      charset = 'gb18030';\n    }\n  } // turn raw buffers into a single utf-8 buffer\n\n\n  return convert(buffer, 'UTF-8', charset).toString();\n}\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\n\n\nexports.clone = function clone(instance) {\n  let p1, p2;\n  let body = instance.body; // don't allow cloning a used body\n\n  if (instance.bodyUsed) {\n    throw new Error('cannot clone body after it is used');\n  } // check that body is a stream and not form-data object\n  // note: we can't clone the form-data object without having it as a dependency\n\n\n  if (body instanceof Stream && typeof body.getBoundary !== 'function') {\n    // tee instance body\n    p1 = new PassThrough();\n    p2 = new PassThrough();\n    body.pipe(p1);\n    body.pipe(p2); // set instance body to teed body and return the other teed body\n\n    instance.body = p1;\n    body = p2;\n  }\n\n  return body;\n};\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present and non-null.\n *\n * @param   Mixed  instance  Response or Request instance\n */\n\n\nexports.extractContentType = function extractContentType(instance) {\n  const body = instance.body; // istanbul ignore if: Currently, because of a guard in Request, body\n  // can never be null. Included here for completeness.\n\n  if (body === null) {\n    // body is null\n    return null;\n  } else if (typeof body === 'string') {\n    // body is string\n    return 'text/plain;charset=UTF-8';\n  } else if (body instanceof Blob) {\n    // body is blob\n    return body.type || null;\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    return null;\n  } else if (typeof body.getBoundary === 'function') {\n    // detect form data input from form-data module\n    return `multipart/form-data;boundary=${body.getBoundary()}`;\n  } else {\n    // body is stream\n    // can't really do much about this\n    return null;\n  }\n};\n\nexports.getTotalBytes = function getTotalBytes(instance) {\n  const body = instance.body; // istanbul ignore if: included for completion\n\n  if (body === null) {\n    // body is null\n    return 0;\n  } else if (typeof body === 'string') {\n    // body is string\n    return Buffer.byteLength(body);\n  } else if (body instanceof Blob) {\n    // body is blob\n    return body.size;\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    return body.length;\n  } else if (body && typeof body.getLengthSync === 'function') {\n    // detect form data input from form-data module\n    if ( // 1.x\n    body._lengthRetrievers && body._lengthRetrievers.length === 0 || // 2.x\n    body.hasKnownLength && body.hasKnownLength()) {\n      return body.getLengthSync();\n    }\n\n    return null;\n  } else {\n    // body is stream\n    // can't really do much about this\n    return null;\n  }\n};\n\nexports.writeToStream = function writeToStream(dest, instance) {\n  const body = instance.body;\n\n  if (body === null) {\n    // body is null\n    dest.end();\n  } else if (typeof body === 'string') {\n    // body is string\n    dest.write(body);\n    dest.end();\n  } else if (body instanceof Blob) {\n    // body is blob\n    dest.write(body[BUFFER]);\n    dest.end();\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    dest.write(body);\n    dest.end();\n  } else {\n    // body is stream\n    body.pipe(dest);\n  }\n}; // expose Promise\n\n\nBody.Promise = global.Promise;","map":{"version":3,"sources":["/Users/moonbox/Documents/capstone/pantrypal/node_modules/npm/node_modules/node-fetch-npm/src/body.js"],"names":["Buffer","require","Blob","BUFFER","convert","parseJson","FetchError","Stream","PassThrough","DISTURBED","Symbol","exports","module","Body","body","opts","size","timeout","isBuffer","String","prototype","bodyUsed","arrayBuffer","consumeBody","call","then","buf","buffer","slice","byteOffset","byteLength","blob","ct","headers","get","Object","assign","type","toLowerCase","json","toString","text","textConverted","convertBody","mixIn","proto","name","getOwnPropertyNames","desc","getOwnPropertyDescriptor","defineProperty","Promise","reject","Error","url","resolve","alloc","from","accum","accumBytes","abort","resTimeout","setTimeout","on","err","message","chunk","length","push","clearTimeout","concat","charset","res","str","exec","pop","clone","instance","p1","p2","getBoundary","pipe","extractContentType","getTotalBytes","getLengthSync","_lengthRetrievers","hasKnownLength","writeToStream","dest","end","write","global"],"mappings":"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","sourcesContent":["'use strict'\n\n/**\n * body.js\n *\n * Body interface provides common methods for Request and Response\n */\n\nconst Buffer = require('safe-buffer').Buffer\n\nconst Blob = require('./blob.js')\nconst BUFFER = Blob.BUFFER\nconst convert = require('encoding').convert\nconst parseJson = require('json-parse-better-errors')\nconst FetchError = require('./fetch-error.js')\nconst Stream = require('stream')\n\nconst PassThrough = Stream.PassThrough\nconst DISTURBED = Symbol('disturbed')\n\n/**\n * Body class\n *\n * Cannot use ES6 class because Body must be called with .call().\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nexports = module.exports = Body\n\nfunction Body (body, opts) {\n  if (!opts) opts = {}\n  const size = opts.size == null ? 0 : opts.size\n  const timeout = opts.timeout == null ? 0 : opts.timeout\n  if (body == null) {\n    // body is undefined or null\n    body = null\n  } else if (typeof body === 'string') {\n    // body is string\n  } else if (body instanceof Blob) {\n    // body is blob\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n  } else if (body instanceof Stream) {\n    // body is stream\n  } else {\n    // none of the above\n    // coerce to string\n    body = String(body)\n  }\n  this.body = body\n  this[DISTURBED] = false\n  this.size = size\n  this.timeout = timeout\n}\n\nBody.prototype = {\n  get bodyUsed () {\n    return this[DISTURBED]\n  },\n\n  /**\n   * Decode response as ArrayBuffer\n   *\n   * @return  Promise\n   */\n  arrayBuffer () {\n    return consumeBody.call(this).then(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n  },\n\n  /**\n   * Return raw response as Blob\n   *\n   * @return Promise\n   */\n  blob () {\n    let ct = (this.headers && this.headers.get('content-type')) || ''\n    return consumeBody.call(this).then(buf => Object.assign(\n      // Prevent copying\n      new Blob([], {\n        type: ct.toLowerCase()\n      }),\n      {\n        [BUFFER]: buf\n      }\n    ))\n  },\n\n  /**\n   * Decode response as json\n   *\n   * @return  Promise\n   */\n  json () {\n    return consumeBody.call(this).then(buffer => parseJson(buffer.toString()))\n  },\n\n  /**\n   * Decode response as text\n   *\n   * @return  Promise\n   */\n  text () {\n    return consumeBody.call(this).then(buffer => buffer.toString())\n  },\n\n  /**\n   * Decode response as buffer (non-spec api)\n   *\n   * @return  Promise\n   */\n  buffer () {\n    return consumeBody.call(this)\n  },\n\n  /**\n   * Decode response as text, while automatically detecting the encoding and\n   * trying to decode to UTF-8 (non-spec api)\n   *\n   * @return  Promise\n   */\n  textConverted () {\n    return consumeBody.call(this).then(buffer => convertBody(buffer, this.headers))\n  }\n\n}\n\nBody.mixIn = function (proto) {\n  for (const name of Object.getOwnPropertyNames(Body.prototype)) {\n    // istanbul ignore else: future proof\n    if (!(name in proto)) {\n      const desc = Object.getOwnPropertyDescriptor(Body.prototype, name)\n      Object.defineProperty(proto, name, desc)\n    }\n  }\n}\n\n/**\n * Decode buffers into utf-8 string\n *\n * @return  Promise\n */\nfunction consumeBody (body) {\n  if (this[DISTURBED]) {\n    return Body.Promise.reject(new Error(`body used already for: ${this.url}`))\n  }\n\n  this[DISTURBED] = true\n\n  // body is null\n  if (this.body === null) {\n    return Body.Promise.resolve(Buffer.alloc(0))\n  }\n\n  // body is string\n  if (typeof this.body === 'string') {\n    return Body.Promise.resolve(Buffer.from(this.body))\n  }\n\n  // body is blob\n  if (this.body instanceof Blob) {\n    return Body.Promise.resolve(this.body[BUFFER])\n  }\n\n  // body is buffer\n  if (Buffer.isBuffer(this.body)) {\n    return Body.Promise.resolve(this.body)\n  }\n\n  // istanbul ignore if: should never happen\n  if (!(this.body instanceof Stream)) {\n    return Body.Promise.resolve(Buffer.alloc(0))\n  }\n\n  // body is stream\n  // get ready to actually consume the body\n  let accum = []\n  let accumBytes = 0\n  let abort = false\n\n  return new Body.Promise((resolve, reject) => {\n    let resTimeout\n\n    // allow timeout on slow response body\n    if (this.timeout) {\n      resTimeout = setTimeout(() => {\n        abort = true\n        reject(new FetchError(`Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`, 'body-timeout'))\n      }, this.timeout)\n    }\n\n    // handle stream error, such as incorrect content-encoding\n    this.body.on('error', err => {\n      reject(new FetchError(`Invalid response body while trying to fetch ${this.url}: ${err.message}`, 'system', err))\n    })\n\n    this.body.on('data', chunk => {\n      if (abort || chunk === null) {\n        return\n      }\n\n      if (this.size && accumBytes + chunk.length > this.size) {\n        abort = true\n        reject(new FetchError(`content size at ${this.url} over limit: ${this.size}`, 'max-size'))\n        return\n      }\n\n      accumBytes += chunk.length\n      accum.push(chunk)\n    })\n\n    this.body.on('end', () => {\n      if (abort) {\n        return\n      }\n\n      clearTimeout(resTimeout)\n      resolve(Buffer.concat(accum))\n    })\n  })\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody (buffer, headers) {\n  const ct = headers.get('content-type')\n  let charset = 'utf-8'\n  let res, str\n\n  // header\n  if (ct) {\n    res = /charset=([^;]*)/i.exec(ct)\n  }\n\n  // no charset in content type, peek at response body for at most 1024 bytes\n  str = buffer.slice(0, 1024).toString()\n\n  // html5\n  if (!res && str) {\n    res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str)\n  }\n\n  // html4\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str)\n\n    if (res) {\n      res = /charset=(.*)/i.exec(res.pop())\n    }\n  }\n\n  // xml\n  if (!res && str) {\n    res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str)\n  }\n\n  // found charset\n  if (res) {\n    charset = res.pop()\n\n    // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n    if (charset === 'gb2312' || charset === 'gbk') {\n      charset = 'gb18030'\n    }\n  }\n\n  // turn raw buffers into a single utf-8 buffer\n  return convert(\n    buffer\n    , 'UTF-8'\n    , charset\n  ).toString()\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nexports.clone = function clone (instance) {\n  let p1, p2\n  let body = instance.body\n\n  // don't allow cloning a used body\n  if (instance.bodyUsed) {\n    throw new Error('cannot clone body after it is used')\n  }\n\n  // check that body is a stream and not form-data object\n  // note: we can't clone the form-data object without having it as a dependency\n  if ((body instanceof Stream) && (typeof body.getBoundary !== 'function')) {\n    // tee instance body\n    p1 = new PassThrough()\n    p2 = new PassThrough()\n    body.pipe(p1)\n    body.pipe(p2)\n    // set instance body to teed body and return the other teed body\n    instance.body = p1\n    body = p2\n  }\n\n  return body\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present and non-null.\n *\n * @param   Mixed  instance  Response or Request instance\n */\nexports.extractContentType = function extractContentType (instance) {\n  const body = instance.body\n\n  // istanbul ignore if: Currently, because of a guard in Request, body\n  // can never be null. Included here for completeness.\n  if (body === null) {\n    // body is null\n    return null\n  } else if (typeof body === 'string') {\n    // body is string\n    return 'text/plain;charset=UTF-8'\n  } else if (body instanceof Blob) {\n    // body is blob\n    return body.type || null\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    return null\n  } else if (typeof body.getBoundary === 'function') {\n    // detect form data input from form-data module\n    return `multipart/form-data;boundary=${body.getBoundary()}`\n  } else {\n    // body is stream\n    // can't really do much about this\n    return null\n  }\n}\n\nexports.getTotalBytes = function getTotalBytes (instance) {\n  const body = instance.body\n\n  // istanbul ignore if: included for completion\n  if (body === null) {\n    // body is null\n    return 0\n  } else if (typeof body === 'string') {\n    // body is string\n    return Buffer.byteLength(body)\n  } else if (body instanceof Blob) {\n    // body is blob\n    return body.size\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    return body.length\n  } else if (body && typeof body.getLengthSync === 'function') {\n    // detect form data input from form-data module\n    if ((\n      // 1.x\n      body._lengthRetrievers &&\n      body._lengthRetrievers.length === 0\n    ) || (\n      // 2.x\n      body.hasKnownLength && body.hasKnownLength()\n    )) {\n      return body.getLengthSync()\n    }\n    return null\n  } else {\n    // body is stream\n    // can't really do much about this\n    return null\n  }\n}\n\nexports.writeToStream = function writeToStream (dest, instance) {\n  const body = instance.body\n\n  if (body === null) {\n    // body is null\n    dest.end()\n  } else if (typeof body === 'string') {\n    // body is string\n    dest.write(body)\n    dest.end()\n  } else if (body instanceof Blob) {\n    // body is blob\n    dest.write(body[BUFFER])\n    dest.end()\n  } else if (Buffer.isBuffer(body)) {\n    // body is buffer\n    dest.write(body)\n    dest.end()\n  } else {\n    // body is stream\n    body.pipe(dest)\n  }\n}\n\n// expose Promise\nBody.Promise = global.Promise\n"]},"metadata":{},"sourceType":"script"}