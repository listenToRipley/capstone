{"ast":null,"code":"'use strict';\n\nvar _jsonwebtoken = require('jsonwebtoken');\n\nvar _jsonwebtoken2 = _interopRequireDefault(_jsonwebtoken);\n\nvar _errors = require('../errors');\n\nvar _JwksClient = require('../JwksClient');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar handleSigningKeyError = function handleSigningKeyError(err, cb) {\n  // If we didn't find a match, can't provide a key.\n  if (err && err.name === 'SigningKeyNotFoundError') {\n    return cb(null);\n  } // If an error occured like rate limiting or HTTP issue, we'll bubble up the error.\n\n\n  if (err) {\n    return cb(err);\n  }\n};\n\nmodule.exports.passportJwtSecret = function (options) {\n  if (options === null || options === undefined) {\n    throw new _errors.ArgumentError('An options object must be provided when initializing passportJwtSecret');\n  }\n\n  var client = new _JwksClient.JwksClient(options);\n  var onError = options.handleSigningKeyError || handleSigningKeyError;\n  return function secretProvider(req, rawJwtToken, cb) {\n    var decoded = _jsonwebtoken2.default.decode(rawJwtToken, {\n      complete: true\n    }); // Only RS256 is supported.\n\n\n    if (!decoded || !decoded.header || decoded.header.alg !== 'RS256') {\n      return cb(null, null);\n    }\n\n    client.getSigningKey(decoded.header.kid, function (err, key) {\n      if (err) {\n        return onError(err, function (newError) {\n          return cb(newError, null);\n        });\n      } // Provide the key.\n\n\n      return cb(null, key.publicKey || key.rsaPublicKey);\n    });\n  };\n};","map":{"version":3,"sources":["/Users/moonbox/Documents/capstone/pantrypal/node_modules/jwks-rsa/lib/integrations/passport.js"],"names":["_jsonwebtoken","require","_jsonwebtoken2","_interopRequireDefault","_errors","_JwksClient","obj","__esModule","default","handleSigningKeyError","err","cb","name","module","exports","passportJwtSecret","options","undefined","ArgumentError","client","JwksClient","onError","secretProvider","req","rawJwtToken","decoded","decode","complete","header","alg","getSigningKey","kid","key","newError","publicKey","rsaPublicKey"],"mappings":"AAAA;;AAEA,IAAIA,aAAa,GAAGC,OAAO,CAAC,cAAD,CAA3B;;AAEA,IAAIC,cAAc,GAAGC,sBAAsB,CAACH,aAAD,CAA3C;;AAEA,IAAII,OAAO,GAAGH,OAAO,CAAC,WAAD,CAArB;;AAEA,IAAII,WAAW,GAAGJ,OAAO,CAAC,eAAD,CAAzB;;AAEA,SAASE,sBAAT,CAAgCG,GAAhC,EAAqC;AAAE,SAAOA,GAAG,IAAIA,GAAG,CAACC,UAAX,GAAwBD,GAAxB,GAA8B;AAAEE,IAAAA,OAAO,EAAEF;AAAX,GAArC;AAAwD;;AAE/F,IAAIG,qBAAqB,GAAG,SAASA,qBAAT,CAA+BC,GAA/B,EAAoCC,EAApC,EAAwC;AAClE;AACA,MAAID,GAAG,IAAIA,GAAG,CAACE,IAAJ,KAAa,yBAAxB,EAAmD;AACjD,WAAOD,EAAE,CAAC,IAAD,CAAT;AACD,GAJiE,CAMlE;;;AACA,MAAID,GAAJ,EAAS;AACP,WAAOC,EAAE,CAACD,GAAD,CAAT;AACD;AACF,CAVD;;AAYAG,MAAM,CAACC,OAAP,CAAeC,iBAAf,GAAmC,UAAUC,OAAV,EAAmB;AACpD,MAAIA,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAKC,SAApC,EAA+C;AAC7C,UAAM,IAAIb,OAAO,CAACc,aAAZ,CAA0B,wEAA1B,CAAN;AACD;;AAED,MAAIC,MAAM,GAAG,IAAId,WAAW,CAACe,UAAhB,CAA2BJ,OAA3B,CAAb;AACA,MAAIK,OAAO,GAAGL,OAAO,CAACP,qBAAR,IAAiCA,qBAA/C;AAEA,SAAO,SAASa,cAAT,CAAwBC,GAAxB,EAA6BC,WAA7B,EAA0Cb,EAA1C,EAA8C;AACnD,QAAIc,OAAO,GAAGvB,cAAc,CAACM,OAAf,CAAuBkB,MAAvB,CAA8BF,WAA9B,EAA2C;AAAEG,MAAAA,QAAQ,EAAE;AAAZ,KAA3C,CAAd,CADmD,CAGnD;;;AACA,QAAI,CAACF,OAAD,IAAY,CAACA,OAAO,CAACG,MAArB,IAA+BH,OAAO,CAACG,MAAR,CAAeC,GAAf,KAAuB,OAA1D,EAAmE;AACjE,aAAOlB,EAAE,CAAC,IAAD,EAAO,IAAP,CAAT;AACD;;AAEDQ,IAAAA,MAAM,CAACW,aAAP,CAAqBL,OAAO,CAACG,MAAR,CAAeG,GAApC,EAAyC,UAAUrB,GAAV,EAAesB,GAAf,EAAoB;AAC3D,UAAItB,GAAJ,EAAS;AACP,eAAOW,OAAO,CAACX,GAAD,EAAM,UAAUuB,QAAV,EAAoB;AACtC,iBAAOtB,EAAE,CAACsB,QAAD,EAAW,IAAX,CAAT;AACD,SAFa,CAAd;AAGD,OAL0D,CAO3D;;;AACA,aAAOtB,EAAE,CAAC,IAAD,EAAOqB,GAAG,CAACE,SAAJ,IAAiBF,GAAG,CAACG,YAA5B,CAAT;AACD,KATD;AAUD,GAlBD;AAmBD,CA3BD","sourcesContent":["'use strict';\n\nvar _jsonwebtoken = require('jsonwebtoken');\n\nvar _jsonwebtoken2 = _interopRequireDefault(_jsonwebtoken);\n\nvar _errors = require('../errors');\n\nvar _JwksClient = require('../JwksClient');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar handleSigningKeyError = function handleSigningKeyError(err, cb) {\n  // If we didn't find a match, can't provide a key.\n  if (err && err.name === 'SigningKeyNotFoundError') {\n    return cb(null);\n  }\n\n  // If an error occured like rate limiting or HTTP issue, we'll bubble up the error.\n  if (err) {\n    return cb(err);\n  }\n};\n\nmodule.exports.passportJwtSecret = function (options) {\n  if (options === null || options === undefined) {\n    throw new _errors.ArgumentError('An options object must be provided when initializing passportJwtSecret');\n  }\n\n  var client = new _JwksClient.JwksClient(options);\n  var onError = options.handleSigningKeyError || handleSigningKeyError;\n\n  return function secretProvider(req, rawJwtToken, cb) {\n    var decoded = _jsonwebtoken2.default.decode(rawJwtToken, { complete: true });\n\n    // Only RS256 is supported.\n    if (!decoded || !decoded.header || decoded.header.alg !== 'RS256') {\n      return cb(null, null);\n    }\n\n    client.getSigningKey(decoded.header.kid, function (err, key) {\n      if (err) {\n        return onError(err, function (newError) {\n          return cb(newError, null);\n        });\n      }\n\n      // Provide the key.\n      return cb(null, key.publicKey || key.rsaPublicKey);\n    });\n  };\n};"]},"metadata":{},"sourceType":"script"}